<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATS_SWING_Strategy_v0.1 - Strategy Analysis</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        .header-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .info-box {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .info-box strong {
            color: #2c3e50;
            display: block;
            margin-bottom: 5px;
        }
        .score {
            font-size: 24px;
            font-weight: bold;
            color: #27ae60;
        }
        .score.low {
            color: #e74c3c;
        }
        .score.medium {
            color: #f39c12;
        }
        .section {
            margin: 25px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .section p {
            margin: 10px 0;
        }
        .section ul, .section ol {
            margin: 10px 0 10px 20px;
            padding-left: 20px;
        }
        .section li {
            margin: 8px 0;
            line-height: 1.6;
        }
        .code-block {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        .badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            background-color: #3498db;
            color: white;
            font-size: 14px;
            margin-right: 10px;
        }
        .badge.yes {
            background-color: #27ae60;
        }
        .badge.no {
            background-color: #95a5a6;
        }
        .pattern-details {
            background-color: #e8f4f8;
            border: 1px solid #3498db;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .pattern-details code {
            background-color: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #c7254e;
        }
        .quality-analysis {
            background-color: #fff9e6;
            border: 1px solid #f1c40f;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
    <style>
        /* KPI Dashboard Styles */
        .kpi-dashboard {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .kpi-dashboard h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        
        .kpi-dashboard h3 {
            color: #34495e;
            margin: 20px 0 15px 0;
            font-size: 1.1em;
        }
        
        .kpi-header-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .kpi-chip {
            background: white;
            border-radius: 20px;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .chip-label {
            color: #7f8c8d;
            font-size: 0.85em;
        }
        
        .chip-value {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .kpi-main-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .kpi-secondary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .kpi-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .kpi-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }
        
        .kpi-card.main {
            padding: 20px;
        }
        
        .kpi-card.main .kpi-value {
            font-size: 1.8em;
        }
        
        .kpi-title {
            color: #7f8c8d;
            font-size: 0.85em;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .kpi-value {
            font-size: 1.4em;
            font-weight: 700;
            color: #2c3e50;
        }
        
        .kpi-value.positive {
            color: #27ae60;
        }
        
        .kpi-value.negative {
            color: #e74c3c;
        }
        
        .kpi-value.neutral {
            color: #7f8c8d;
        }
        
        .kpi-subtitle {
            font-size: 0.8em;
            color: #95a5a6;
            margin-top: 5px;
        }
        
        /* IS/OOS Section */
        .isoos-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .isoos-info {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .isoos-badge {
            padding: 12px 20px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .isoos-badge.is {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }
        
        .isoos-badge.oos {
            background: linear-gradient(135deg, #27ae60 0%, #219a52 100%);
            color: white;
        }
        
        .badge-label {
            font-size: 0.8em;
            opacity: 0.9;
        }
        
        .badge-value {
            font-weight: 600;
        }
        
        .badge-duration {
            font-size: 0.85em;
            opacity: 0.9;
        }
        
        .isoos-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }
        
        /* Period Table */
        .period-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .period-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95em;
        }
        
        .period-table th {
            background: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 2px solid #e9ecef;
        }
        
        .period-table td {
            padding: 12px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .period-table tr:hover {
            background: #f8f9fa;
        }
        
        .period-table .positive {
            color: #27ae60;
            font-weight: 500;
        }
        
        .period-table .negative {
            color: #e74c3c;
            font-weight: 500;
        }
        
        /* Equity Curve Section */
        .equity-section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .equity-section h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            border-left: 4px solid #27ae60;
            padding-left: 15px;
        }
        
        .equity-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }
        
        .legend-item .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }
        
        .legend-item.is .legend-color {
            background: #3498db;
        }
        
        .legend-item.oos .legend-color {
            background: #27ae60;
        }
        
        .legend-item.separator {
            color: #e74c3c;
            font-weight: 500;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }
        
        .equity-source {
            margin-top: 10px;
            text-align: right;
            color: #95a5a6;
        }
        
        .no-data {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            color: #856404;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .kpi-main-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .kpi-secondary-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .chart-container {
                height: 300px;
            }
        }
    </style>
    
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Strategy List</a>
    <a href="MonteCarlo/Individual/FDAX_ATS_Strategy_v0.8_MC.html" 
       style="display: inline-block; margin-left: 15px; padding: 8px 16px; 
              background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
              color: #4ecdc4; text-decoration: none; border-radius: 5px; 
              border: 1px solid #4ecdc4; font-size: 0.9em;">
        üé≤ Monte Carlo
    </a>
        
        <h1>üìä ATS_SWING_Strategy_v0.1</h1>
        
        <div class="header-info">
            <div class="info-box">
                <strong>Strategy Type</strong>
                <span class="badge">Error</span>
            </div>
            <div class="info-box">
                <strong>Subtype</strong>
                <span class="badge">Analysis Failed</span>
            </div>
            <div class="info-box">
                <strong>Complexity Score</strong>
                <span class="score ">N/A/10</span>
            </div>
            <div class="info-box">
                <strong>Quality Score</strong>
                <span class="score ">N/A/10</span>
            </div>
        </div>

        
            <div class="kpi-dashboard">
                <h2>üìà Performance Dashboard</h2>
                <div class="no-data">
                    <p>‚ö†Ô∏è N/A - No performance data available for this strategy in Portfolio Report.</p>
                </div>
            </div>
            

            <div class="equity-section">
                <h2>üìà Equity Curve</h2>
                <div class="no-data">
                    <p>‚ö†Ô∏è N/A - Equity curve data not available (no matching DataSource file).</p>
                </div>
            </div>
            
        <div class="section">
            <h2>üìù Summary</h2>
            <p>Analysis failed: API error: Error code: 429 - {&#39;type&#39;: &#39;error&#39;, &#39;error&#39;: {&#39;type&#39;: &#39;rate_limit_error&#39;, &#39;message&#39;: &#39;This request would exceed the rate limit for your organization (59916927-b287-402d-a37b-4297fcca865c) of 30,000 input tokens per minute. For details, refer to: https://docs.claude.com/en/api/rate-limits. You can see the response headers for current usage. Please reduce the prompt length or the maximum tokens requested, or try again later. You may also contact sales at https://www.anthropic.com/contact-sales to discuss your options for a rate limit increase.&#39;}, &#39;request_id&#39;: &#39;req_011CVUvF8tbitLBx9unCLLEc&#39;}</p>
        </div>

        <div class="section">
            <h2>üéØ Entry Conditions</h2>
            N/A
        </div>

        <div class="section">
            <h2>üö™ Exit Conditions</h2>
            N/A
        </div>

        <div class="header-info">
            <div class="info-box">
                <strong>Stop Loss</strong>
                N/A
            </div>
            <div class="info-box">
                <strong>Take Profit</strong>
                N/A
            </div>
            <div class="info-box">
                <strong>Exit On Close</strong>
                <span class="badge no">N/A</span>
            </div>
            <div class="info-box">
                <strong>Time Exit Condition</strong>
                <span class="badge no">N/A</span>
            </div>
        </div>

        <div class="section">
            <strong>Time Exit Details:</strong>
            N/A
        </div>

        <div class="section">
            <h2>üîß Function Patterns Used</h2>
            <p>No patterns identified</p>
            <p><strong>Number of patterns:</strong> N/A</p>
        </div>

        

        <div class="quality-analysis">
            <h2>‚≠ê Quality Analysis</h2>
            <p>API error: Error code: 429 - {&#39;type&#39;: &#39;error&#39;, &#39;error&#39;: {&#39;type&#39;: &#39;rate_limit_error&#39;, &#39;message&#39;: &#39;This request would exceed the rate limit for your organization (59916927-b287-402d-a37b-4297fcca865c) of 30,000 input tokens per minute. For details, refer to: https://docs.claude.com/en/api/rate-limits. You can see the response headers for current usage. Please reduce the prompt length or the maximum tokens requested, or try again later. You may also contact sales at https://www.anthropic.com/contact-sales to discuss your options for a rate limit increase.&#39;}, &#39;request_id&#39;: &#39;req_011CVUvF8tbitLBx9unCLLEc&#39;}</p>
        </div>

        <h2>üíª Strategy Code</h2>
        <div class="code-block">
            <pre>{ ALGORITHME ATS 
Signaux: UC1, UC2.
Bons resultats, identiques avec FDXM.

Objectif v0.1: Transformation de la strategie ATS_Strategy_v0.8 en SWING avec simplifications associes



}

{ ALGORITHME ATS SWING VERSION - VERSION OPTIMIS?E AVEC AFFICHAGE COMPLET

}

{===========================================================}
{                   D?CLARATIONS GLOBALES                   }
{===========================================================}

//Michael formula calculation begin
Input:SessionStartTimeA(0110), sessionEndTimeA(2200); //Set here your session time!
array:ohlcvalues[23](0), adxCalcValues[3](0);
var:IsStartOfSession(false);


IsStartOfSession=_OHLCMulti5(SessionStartTimeA,sessionEndTimeA,ohlcvalues);
//Michael formula calculation end


{Definition des constantes pour les indices des timeframes}
Vars: 
    TF_1(1), TF_2(2), TF_3(3), TF_4(4), TF_5(5), TF_6(6),
    timeframeIdx(0), indicatorIdx(0), dataStream(0), 
    currentPrice(0);

{Definition des constantes pour les indices des variables}
Vars:
    IDX_M7(1), IDX_M20(2), IDX_BBH(3), IDX_BBL(4), IDX_SAR(5),
    IDX_OGGY1(6), IDX_OGGY2(7), IDX_OGGY3(8),
    IDX_JACK1(9), IDX_JACK2(10), IDX_JACK3(11),
    IDX_CLOSEST_SUPPORT(12), IDX_CLOSEST_RESISTANCE(13);

{Tableaux pour stocker les valeurs numeriques}
Arrays:
    UTData[6,13](0), {6 timeframes x 13 variables numeriques}
    IndicatorsValueArray[6,11,2](0), {6 timeframes x 11 indicateurs x 2 (valeur, au-dessus/en-dessous)}
    IndicatorsNameArray[6,11,2](&quot;&quot;);
   
{Tableaux pour les variables de type string}
Arrays:
    UTLastSignalCode[6](&quot;NC&quot;),
    UTBollPhase[6](&quot;P1&quot;),
    signalHaussier[6](&quot;&quot;), 
    signalBaissier[6](&quot;&quot;);

{Variables pour les distances des signaux}
Arrays:
    UTLastSignalDistance[6](9999);

{Tableau pour stocker les noms des timeframes}
Arrays:
    UTNames[6](&quot;&quot;);

{Tableau pour stocker les durees des P2H}
Arrays:
    UTDureeP2H[6](0);                  // Compteur de barres en P2H par timeframe

{Variables et tableaux pour la Grande Fenetre (GF)}
Vars:
    GF_ClosestSupport(0), 
    GF_ClosestResistance(0),
    GF_isSupportCluster(false), 
    GF_isResistanceCluster(false),
    GF_SupportName(&quot;&quot;), 
    GF_ResistanceName(&quot;&quot;),
    SupportClusterCount(0), 
    ResistanceClusterCount(0),
    clusterIdx(0);

{Tableaux pour la Grande Fenetre}
Arrays:
    GF_Supports[100](0), 
    GF_Resistances[100](0),
    GF_AllIndicatorsValue[100](0), 
    GF_AllIndicatorsName[100](&quot;&quot;);

{Variables pour les signaux de la Grande Fenetre}
Vars: 
    GF_SignauxHaussiers(&quot;&quot;), 
    GF_NbSignauxHaussiersRecents(0),
    GF_SignauxBaissiers(&quot;&quot;), 
    GF_NbSignauxBaissiersRecents(0);

{Variables pour les scenarios de trading}
Vars: 
    GF_PossibleScenarioLong(&quot;&quot;),
    GF_CodeScenarioLong(&quot;&quot;),
    GF_PossibleScenarioShort(&quot;&quot;),
    GF_CodeScenarioShort(&quot;&quot;),
    GF_NbScenarioDetecte(0);
    
{ 2. VARIABLES DE TRACKING MULTI-HORIZONS }
Vars:
    { === TRACKING JOURNALIER === }
    dailyProfit(0), dailyTradingEnabled(true), lastDailyResetDate(0),
    dailyStartProfit(0), dailyTradeCount(0),
    
    { === TRACKING HEBDOMADAIRE === }
    weeklyProfit(0), weeklyTradingEnabled(true), lastWeeklyResetDate(0),
    weeklyStartProfit(0), weeklyTradeCount(0), currentWeek(0),
    
    { === TRACKING MENSUEL === }
    monthlyProfit(0), monthlyTradingEnabled(true), lastMonthlyResetDate(0), 
    monthlyStartProfit(0), monthlyTradeCount(0), currentMonth(0),
    
    { === VARIABLES COMMUNES === }
    globalTradingEnabled(true),        // Flag global (AND de tous les horizons)
    lastTradeExitProfit(0);
{===========================================================}
{        PARAMETRES DE CONFIGURATION UTILISATEUR            }
{===========================================================}

{Parametres Affichage}
Inputs:
	DisplayATSConfiguration(0),
	DisplayPerfo (1);

{Parametres de direction et strategie}
Inputs:
    LONG_UC1_PtnNeut_Yes(12), LONG_UC1_PtnNeut_Yes2(55),LONG_UC1_PtnNeut_No(46), LONG_UC1_PtnNeut_No2(56),LONG_UC1_PtnDir_Yes(52),LONG_UC1_PtnDir_No(35), //optimize Neutral from 1 to 55 (55=true, 56=false). Directional from -152 to 152 (152=true, 153=false)
    LONG_UC2_PtnNeut_Yes(55),LONG_UC2_PtnNeut_No(53), LONG_UC2_PtnNeut_No2(56),LONG_UC2_PtnDir_Yes(55),LONG_UC2_PtnDir_No(16), //optimize Neutral from 1 to 55 (55=true, 56=false). Directional from -152 to 152 (152=true, 153=false)

    noTradingMonth(0), noTradingDay(6),
    param_playLong(true), 
    param_playShort(true),
    param_uc1 (1),
    param_uc2 (1);
    
Inputs:
    param_MinDureeP2H(1),              // Dur?e minimum en P2H avant signal (en barres)
    param_MaxDureeP2H(20),             // Dur?e maximum en P2H pour ?viter signaux tardifs
    param_EnableDureeP2HFilter(true);  // Activer/d?sactiver le filtre dur?e P2H

Inputs:
    param_exit_uc1 (0);

{Parametres d&#39;analyse technique}
Inputs:
    param_ClusterPips(5);

{Parametres de gestion du risque}
Inputs:

    param_SLLong(100), 
    param_TPLong(70), 
    param_TrailingSL (60);

{Parametres de Money Management}    
Inputs:
    { === PARAMETRES JOURNALIERS === }
    param_DailyLossLimit(-5000),        // Limite de perte journali?re
    param_DailyProfitTarget(1000),     // Objectif de profit journalier
    param_EnableDailyLossFilter(1), 
    param_EnableDailyProfitTarget(0),
    param_DailyResetHour(0000),        // Reset journalier
    
    { === PARAMETRES HEBDOMADAIRES === }
    param_WeeklyLossLimit(-12500),      // Limite de perte hebdomadaire
    param_WeeklyProfitTarget(3000),    // Objectif de profit hebdomadaire
    param_EnableWeeklyLossFilter(1),
    param_EnableWeeklyProfitTarget(0),
    param_WeeklyResetDay(1),           // 1=Dimanche, 2=Lundi, etc.
    
    { === PARAMETRES MENSUELS === }
    param_MonthlyLossLimit(-20000),     // Limite de perte mensuelle
    param_MonthlyProfitTarget(8000),   // Objectif de profit mensuel
    param_EnableMonthlyLossFilter(1),
    param_EnableMonthlyProfitTarget(0),
    param_MonthlyResetDay(1);          // Jour du mois pour reset (1er)    

{Parametres de session de trading}
Inputs:
    session_StartTime(0100), 
    session_EndTime(2000), 
    session_PauseStart1(800), 
    session_PauseEnd1(1000),
    session_PauseStart2(2300), 
    session_PauseEnd2(2300);
    
{Parametres de gestion des positions}
Inputs:
    param_MaxDaysInTrade(5), 
    param_CloseOnFriday(1), 
    param_ExitOnSessionClose(1), 
    myContract(2);

{Variables de position consolid?es}
Vars:
    positionOpen(false), 
    positionType(0), 
    entryPrice(0),
    stopPrice(0), 
    targetPrice(0), 
    entryDate(0), 
    entryTime(0),
    breakEvenActive(false), 
    currentProfit(0);

{Variables de session consolid?es}
Vars:
    currentTime(0), 
    currentDate(0), 
    daysSinceEntry(0),
    inTradingHours(false), 
    inPauseTime(false), 
    isFriday(false),
    shouldExit(false), 
    canTradeLong(false), 
    canTradeShort(false);

{Variables pour calculs Bollinger factoris?es}
Vars:
    bbMiddle(0), bbUpper(0), bbLower(0), bbStdDev(0);

{===========================================================}
{                INITIALISATION DU SYST?ME                  }
{===========================================================}

Once Begin
    {Definir les noms des timeframes}
    UTNames[TF_1] = &quot;1D&quot;;
    UTNames[TF_2] = &quot;1W&quot;;
    UTNames[TF_3] = &quot;1M&quot;;
    UTNames[TF_4] = &quot;1Q&quot;;
    UTNames[TF_5] = &quot;1S&quot;;
    UTNames[TF_6] = &quot;1Y&quot;;
    
    {Initialisation des tableaux de signaux}
    signalHaussier[1] = &quot;XH-M7-M20&quot;; 
    signalHaussier[2] = &quot;xH M7-M20&quot;; 
    signalHaussier[3] = &quot;NXH&quot;; 
    signalHaussier[4] = &quot;XPH&quot;; 
    signalHaussier[5] = &quot;XPH2&quot;;
    
    signalBaissier[1] = &quot;XB-M7-M20&quot;; 
    signalBaissier[2] = &quot;xB M7-M20&quot;; 
    signalBaissier[3] = &quot;NXB&quot;; 
    signalBaissier[4] = &quot;XPB&quot;; 
    signalBaissier[5] = &quot;XPB2&quot;;

    Print(&quot;---- Initialisation du systeme ----&quot;);
    Print(&quot;Date de demarrage:&quot;, Date, &quot; Heure:&quot;, Time);
End;

{ ============== GESTION DES RESETS MULTI-HORIZONS ============== }

{ === RESET JOURNALIER === }
If Date &lt;&gt; lastDailyResetDate Then Begin // OR (Time = param_DailyResetHour AND Time[1] &lt;&gt; param_DailyResetHour) Then Begin
    If dailyProfit &lt;&gt; 0 Then Begin
        Print(&quot;=== BILAN JOURNALIER ===&quot;);
        Print(&quot;Date: &quot;, lastDailyResetDate, &quot; | Profit: &quot;, dailyProfit, &quot; | Trades: &quot;, dailyTradeCount);
    End;
    
    dailyProfit = 0;
    dailyTradingEnabled = true;
    dailyTradeCount = 0;
    lastDailyResetDate = Date;
    dailyStartProfit = NetProfit;
    
    Print(&quot;Reset journalier - Date: &quot;, Date);
End;

{ === RESET HEBDOMADAIRE === }
If DayOfWeek(Date) = param_WeeklyResetDay AND DayOfWeek(Date[1]) &lt;&gt; param_WeeklyResetDay Then Begin
    If weeklyProfit &lt;&gt; 0 Then Begin
        Print(&quot;=== BILAN HEBDOMADAIRE ===&quot;);
        Print(&quot;Semaine termin?e | Profit: &quot;, weeklyProfit, &quot; | Trades: &quot;, weeklyTradeCount);
        //Print(&quot;Status: &quot;, IFF(weeklyTradingEnabled, &quot;ACTIF&quot;, &quot;BLOQUE&quot;));
    End;
    
    weeklyProfit = 0;
    weeklyTradingEnabled = true;
    weeklyTradeCount = 0;
    lastWeeklyResetDate = Date;
    weeklyStartProfit = NetProfit;
    currentWeek = currentWeek + 1;
    
    Print(&quot;=== NOUVELLE SEMAINE ===&quot;);
    Print(&quot;Semaine #&quot;, currentWeek, &quot; | Reset le: &quot;, Date);
End;

{ === RESET MENSUEL === }
If Month(Date) &lt;&gt; Month(Date[1]) Then Begin //DayOfMonth(Date) = param_MonthlyResetDay AND DayOfMonth(Date[1]) &lt;&gt; param_MonthlyResetDay Then Begin
    If monthlyProfit &lt;&gt; 0 Then Begin
        Print(&quot;=== BILAN MENSUEL ===&quot;);
        Print(&quot;Mois: &quot;, Month(Date[1]), &quot;/&quot;, Year(Date[1]));
        Print(&quot;Profit mensuel: &quot;, monthlyProfit, &quot; | Trades: &quot;, monthlyTradeCount);
        //Print(&quot;Status final: &quot;, IFF(monthlyTradingEnabled, &quot;ACTIF&quot;, &quot;BLOQUE&quot;));
    End;
    
    monthlyProfit = 0;
    monthlyTradingEnabled = true;
    monthlyTradeCount = 0;
    lastMonthlyResetDate = Date;
    monthlyStartProfit = NetProfit;
    currentMonth = Month(Date);
    
    Print(&quot;=== NOUVEAU MOIS ===&quot;);
    Print(&quot;Mois: &quot;, Month(Date), &quot;/&quot;, Year(Date), &quot; | Reset le: &quot;, Date);
End;


{ 4. CALCUL DES PROFITS EN TEMPS REEL }

{ ============== CALCUL DES PROFITS MULTI-HORIZONS ============== }
{ Calcul base sur NetProfit }
dailyProfit = NetProfit - dailyStartProfit;
weeklyProfit = NetProfit - weeklyStartProfit;
monthlyProfit = NetProfit - monthlyStartProfit;

{ Tracking des trades ferm?s }
If MarketPosition = 0 AND MarketPosition[1] &lt;&gt; 0 Then Begin
    lastTradeExitProfit = NetProfit - NetProfit[1];
    
    { Mise a jour des compteurs si trade ferme dans la periode courante }
    If Date = lastDailyResetDate Then
        dailyTradeCount = dailyTradeCount + 1;
    If Date &gt;= lastWeeklyResetDate Then
        weeklyTradeCount = weeklyTradeCount + 1;
    If Date &gt;= lastMonthlyResetDate Then
        monthlyTradeCount = monthlyTradeCount + 1;
        
    Print(&quot;Trade ferm? - P&amp;L: &quot;, lastTradeExitProfit);
    Print(&quot;Profits - Jour: &quot;, dailyProfit, &quot; | Semaine: &quot;, weeklyProfit, &quot; | Mois: &quot;, monthlyProfit);
End;

{ 5. VERIFICATION DES LIMITES MULTI-HORIZONS }

{ ============== VERIFICATION DES LIMITES JOURNALIERES ============== }
If param_EnableDailyLossFilter=1 AND dailyProfit &lt;= param_DailyLossLimit AND dailyTradingEnabled Then Begin
    dailyTradingEnabled = false;
    Print(&quot;*** LIMITE JOURNALIERE ATTEINTE ***&quot;);
    Print(&quot;Profit jour: &quot;, dailyProfit, &quot; | Limite: &quot;, param_DailyLossLimit);
    Print(&quot;TRADING SUSPENDU jusqu&#39;a demain&quot;);
End;

If param_EnableDailyProfitTarget=1 AND dailyProfit &gt;= param_DailyProfitTarget AND dailyTradingEnabled Then Begin
    dailyTradingEnabled = false;
    Print(&quot;*** OBJECTIF JOURNALIER ATTEINT ***&quot;);
    Print(&quot;Profit jour: &quot;, dailyProfit, &quot; | Objectif: &quot;, param_DailyProfitTarget);
    Print(&quot;TRADING SUSPENDU jusqu&#39;? demain&quot;);
End;

{ ============== VERIFICATION DES LIMITES HEBDOMADAIRES ============== }
If param_EnableWeeklyLossFilter=1 AND weeklyProfit &lt;= param_WeeklyLossLimit AND weeklyTradingEnabled Then Begin
    weeklyTradingEnabled = false;
    Print(&quot;*** LIMITE HEBDOMADAIRE ATTEINTE ***&quot;);
    Print(&quot;Profit semaine: &quot;, weeklyProfit, &quot; | Limite: &quot;, param_WeeklyLossLimit);
    Print(&quot;TRADING SUSPENDU jusqu&#39;? la semaine prochaine&quot;);
End;

If param_EnableWeeklyProfitTarget=1 AND weeklyProfit &gt;= param_WeeklyProfitTarget AND weeklyTradingEnabled Then Begin
    weeklyTradingEnabled = false;
    Print(&quot;*** OBJECTIF HEBDOMADAIRE ATTEINT ***&quot;);
    Print(&quot;Profit semaine: &quot;, weeklyProfit, &quot; | Objectif: &quot;, param_WeeklyProfitTarget);
    Print(&quot;TRADING SUSPENDU jusqu&#39;a la semaine prochaine&quot;);
End;

{ ============== VERIFICATION DES LIMITES MENSUELLES ============== }
If param_EnableMonthlyLossFilter=1 AND monthlyProfit &lt;= param_MonthlyLossLimit AND monthlyTradingEnabled Then Begin
    monthlyTradingEnabled = false;
    Print(&quot;*** LIMITE MENSUELLE ATTEINTE ***&quot;);
    Print(&quot;Profit mois: &quot;, monthlyProfit, &quot; | Limite: &quot;, param_MonthlyLossLimit);
    Print(&quot;TRADING SUSPENDU jusqu&#39;au mois prochain&quot;);
End;

If param_EnableMonthlyProfitTarget=1 AND monthlyProfit &gt;= param_MonthlyProfitTarget AND monthlyTradingEnabled Then Begin
    monthlyTradingEnabled = false;
    Print(&quot;*** OBJECTIF MENSUEL ATTEINT ***&quot;);
    Print(&quot;Profit mois: &quot;, monthlyProfit, &quot; | Objectif: &quot;, param_MonthlyProfitTarget);
    Print(&quot;TRADING SUSPENDU jusqu&#39;au mois prochain&quot;);
End;

{ 6. CALCUL DU FLAG GLOBAL DE TRADING }

{ ============== FLAG GLOBAL DE TRADING ============== }
{ Le trading n&#39;est autorise que si TOUS les horizons sont OK }
globalTradingEnabled = dailyTradingEnabled AND weeklyTradingEnabled AND monthlyTradingEnabled;

{ Fermeture forcee si l&#39;un des horizons est bloque }
If NOT globalTradingEnabled AND MarketPosition &lt;&gt; 0 Then Begin
    {
    Print(&quot;*** FERMETURE FORCEE - LIMITE ATTEINTE ***&quot;);
    If NOT dailyTradingEnabled Then Print(&quot;Cause: Limite journali?re&quot;);
    If NOT weeklyTradingEnabled Then Print(&quot;Cause: Limite hebdomadaire&quot;);
    If NOT monthlyTradingEnabled Then Print(&quot;Cause: Limite mensuelle&quot;);
    }
    If MarketPosition &gt; 0 Then
        Sell(&quot;Limit_Exit&quot;) currentcontracts contracts next bar at market
    Else
        BuyToCover(&quot;Limit_Exit&quot;) next bar at market;
End;
{===========================================================}
{              TRAITEMENT PRINCIPAL DU SYSTEME              }
{===========================================================}

{===========================================================}
{           MODULE 1: CALCUL DES CONDITIONS GLOBALES        }
{===========================================================}

{Calcul des conditions de session une seule fois}
currentTime = Time;
currentDate = Date;
isFriday = DayOfWeek(currentDate) = 5;
inTradingHours = (currentTime &gt;= session_StartTime AND currentTime &lt;= session_EndTime);
inPauseTime = (currentTime &gt;= session_PauseStart1 AND currentTime &lt;= session_PauseEnd1);
canTradeLong = param_playLong AND inTradingHours AND NOT inPauseTime;
canTradeShort = param_playShort AND inTradingHours AND NOT inPauseTime;

{Recuperer le prix actuel une seule fois}
currentPrice = Close;

{===========================================================}
{           MODULE 2: CALCUL DES INDICATEURS PAR UT         }
{===========================================================}

{BOUCLE PRINCIPALE OPTIMIS?E}
For timeframeIdx = TF_1 To TF_6 
Begin
    {Variables locales factoris?es pour les calculs}
    Vars: 
        m7(0), m7_1(0), m7_2(0), m7_3(0),
        m20(0), m20_1(0), m20_2(0), m20_3(0),
        close_1(0), close_2(0), close_3(0),
        currentPhase(&quot;&quot;),
        supportCounter(0), resistanceCounter(0),
        minSupportValue(999999), minResistanceValue(999999);
    
    {Selection du bon flux de donnees selon le timeframe}
    If timeframeIdx = TF_1 Then dataStream = 1
    Else If timeframeIdx = TF_2 Then dataStream = 2
    Else If timeframeIdx = TF_3 Then dataStream = 3
    Else If timeframeIdx = TF_4 Then dataStream = 4
    Else If timeframeIdx = TF_5 Then dataStream = 5
    Else dataStream = 6;
    
    {CALCUL DES INDICATEURS PRINCIPAUX - FACTORIS?}
    UTData[timeframeIdx, IDX_M7] = Average(Close of data(dataStream), 7);
    UTData[timeframeIdx, IDX_M20] = Average(Close of data(dataStream), 20);
    UTData[timeframeIdx, IDX_SAR] = ATS_ParabolicSAR_TF(0.02, 0.02, 0.2) of Data(dataStream);
    
    {Calcul des Bandes de Bollinger factoris?}
    bbMiddle = UTData[timeframeIdx, IDX_M20];
    bbStdDev = StandardDev(Close of data(dataStream), 20, 1);
    UTData[timeframeIdx, IDX_BBH] = bbMiddle + 2 * bbStdDev;
    UTData[timeframeIdx, IDX_BBL] = bbMiddle - 2 * bbStdDev;
    
    {Calcul des Oggy et Jack}
    UTData[timeframeIdx, IDX_OGGY1] = Close[7] of data(dataStream);
    UTData[timeframeIdx, IDX_OGGY2] = Close[6] of data(dataStream);
    UTData[timeframeIdx, IDX_OGGY3] = Close[5] of data(dataStream);
    UTData[timeframeIdx, IDX_JACK1] = Close[20] of data(dataStream);
    UTData[timeframeIdx, IDX_JACK2] = Close[19] of data(dataStream);
    UTData[timeframeIdx, IDX_JACK3] = Close[18] of data(dataStream);
    
    {===========================================================}
    {     MODULE 2.1: DETERMINATION DES PHASES DE BOLLINGER     }
    {===========================================================}
    
    m7 = UTData[timeframeIdx, IDX_M7];
    m7_1 = Average(Close[1] of data(dataStream), 7);
    m7_2 = Average(Close[2] of data(dataStream), 7);
    
    {Calcul des phases de Bollinger simplifi?}
    bbUpper = UTData[timeframeIdx, IDX_BBH];
    bbLower = UTData[timeframeIdx, IDX_BBL];
    
    {Calcul des valeurs pr?c?dentes pour comparaison}
    bbStdDev = StandardDev(Close[1] of data(dataStream), 20, 1);
    bbMiddle = Average(Close[1] of data(dataStream), 20);
    Vars: bbUpper_1(0), bbLower_1(0);
    bbUpper_1 = bbMiddle + 2 * bbStdDev;
    bbLower_1 = bbMiddle - 2 * bbStdDev;
    
    {Logique de phases simplifi?e}
    If (bbUpper &gt; bbUpper_1 AND bbLower &lt; bbLower_1) Then 
    Begin {Expansion}
        If m7 &gt; m7_1 Then
            currentPhase = &quot;P2H&quot;
        Else 
        	If m7 &lt; m7_1 Then
            		currentPhase = &quot;P2B&quot;
        	Else
            		currentPhase = &quot;P4&quot;;
    End
    Else 
    	If (bbUpper &lt; bbUpper_1 AND bbLower &gt; bbLower_1) Then {Contraction}
       	currentPhase = &quot;P4&quot;
    	Else 
    		If (bbUpper &gt;= bbUpper_1 AND bbLower &gt;= bbLower_1) Then {Mont?e}
        		currentPhase = &quot;P3H&quot;
    		Else 
    			If (bbUpper &lt;= bbUpper_1 AND bbLower &lt;= bbLower_1) Then {Descente}
        			currentPhase = &quot;P3B&quot;
    			Else
        			currentPhase = &quot;P1&quot;;
        			
    {CORRECTIONS DES SEQUENCES PRINCIPALES DE PHASES}    					
    if currentPhase = &quot;P1&quot; and UTBollPhase[timeframeIdx][1] = &quot;P2H&quot; Then currentPhase=&quot;P2H&quot;;
    if currentPhase = &quot;P1&quot; and UTBollPhase[timeframeIdx][1] = &quot;P2B&quot; Then currentPhase=&quot;P2B&quot;;
    if currentPhase = &quot;P1&quot; and UTBollPhase[timeframeIdx][1] = &quot;P4&quot; and (bbUpper &lt; bbUpper_1 AND bbLower &gt; bbLower_1) Then currentPhase=&quot;P4&quot;;
    if currentPhase = &quot;P4&quot; and UTBollPhase[timeframeIdx][1] = &quot;P1&quot; then currentPhase=&quot;P1&quot;;
    if currentPhase = &quot;P3B&quot; and UTBollPhase[timeframeIdx][1] = &quot;P1&quot; then currentPhase=&quot;P1&quot;;
    if currentPhase = &quot;P3H&quot; and UTBollPhase[timeframeIdx][1] = &quot;P1&quot; then currentPhase=&quot;P1&quot;;

    
    
    {Mettre a jour la phase de Bollinger pour ce timeframe}
    UTBollPhase[timeframeIdx] = currentPhase;
    
    
    { ============== CALCUL DE LA DUREE EN P2H ============== }
    If UTBollPhase[timeframeIdx] = &quot;P2H&quot; Then 
    Begin
      { Si on ?tait d?j? en P2H la barre pr?c?dente, incr?menter le compteur }
    	If UTBollPhase[timeframeIdx][1] = &quot;P2H&quot; Then
      	UTDureeP2H[timeframeIdx] = UTDureeP2H[timeframeIdx] + 1
      Else
      	UTDureeP2H[timeframeIdx] = 1;  // Premi?re barre en P2H
	End
    Else Begin
	    { Si on n&#39;est plus en P2H, remettre le compteur ? z?ro }
	    UTDureeP2H[timeframeIdx] = 0;
    End;
    
    
    {===========================================================}
    {     MODULE 2.2: DETECTION DES SIGNAUX DE TENDANCE         }
    {===========================================================}

    m7 = UTData[timeframeIdx, IDX_M7];
    m7_1 = Average(Close[1] of data(dataStream), 7);
    m7_2 = Average(Close[2] of data(dataStream), 7);
    m7_3 = Average(Close[3] of data(dataStream), 7);

    m20 = UTData[timeframeIdx, IDX_M20];
    m20_1 = Average(Close[1] of data(dataStream), 20);
    m20_2 = Average(Close[2] of data(dataStream), 20);
    m20_3 = Average(Close[3] of data(dataStream), 20);

    
    close_1 = Close[1] of data(dataStream);
    close_2 = Close[2] of data(dataStream);
    close_3 = Close[3] of data(dataStream);
    
    {Variables pour les calculs de signaux - FACTORIS?}
    Vars:
        m7_crossover_m20(false), m7_crossunder_m20(false),
        m7_haussiere(false), m20_haussiere(false),
        m7_baissiere(false), m20_baissiere(false),
        m20_haussiere_3_periodes (false), m7_au_dessus_m20_3_periodes (false), m7_devient_haussiere (false),
        m20_baissiere_3_periodes (false), m7_en_dessous_m20_3_periodes (false), m7_devient_baissiere(false),
        signalFound(false);
    
    m7_crossover_m20 = (m7_1 &lt; m20_1 AND m7 &gt; m20);
    m7_crossunder_m20 = (m7_1 &gt; m20_1 AND m7 &lt; m20);
    m7_haussiere = (m7 &gt; m7_1);
    m20_haussiere = (m20 &gt; m20_1);
    m7_baissiere = (m7 &lt; m7_1);
    m20_baissiere = (m20 &lt; m20_1);
    
    signalFound = false;
    
    {Detection des croisements - SIMPLIFI?}
    If m7_crossover_m20 Then Begin
        If m7_haussiere AND m20_haussiere Then
            UTLastSignalCode[timeframeIdx] = &quot;XH&quot;
        Else
            UTLastSignalCode[timeframeIdx] = &quot;xH&quot;;
        UTLastSignalDistance[timeframeIdx] = 0;
        signalFound = true;
    End
    Else If m7_crossunder_m20 Then Begin
        If m7_baissiere AND m20_baissiere Then
            UTLastSignalCode[timeframeIdx] = &quot;XB&quot;
        Else
            UTLastSignalCode[timeframeIdx] = &quot;xB&quot;;
        UTLastSignalDistance[timeframeIdx] = 0;
        signalFound = true;
    End;
    
    {Detection NXH/NXB - SIMPLIFI?}
	{CAS N?3 HAUSSIER : NON CROISEMENT HAUSSIER}
	m20_haussiere_3_periodes    =  m20_3&lt;m20_2 and m20_2&lt;m20_1 and m20_1 &lt; m20 ;
	m7_au_dessus_m20_3_periodes =  m7_2&gt;m20_2 and m7_1&gt;m20_1 and m7&gt;m20;
	m7_devient_haussiere		=  m7_1&lt;m7_2 and m7_2&lt;m7_3 and m7&gt;m7_1+1 ;
	
	If ( m20_haussiere_3_periodes and m7_au_dessus_m20_3_periodes and m7_devient_haussiere) Then Begin
		UTLastSignalCode[timeframeIdx] = &quot;NXH&quot;;
		UTLastSignalDistance[timeframeIdx] = 0;
		signalFound = true;
	End;
	
	{CAS 3 BAISSIER : NON CROISEMENT BAISSIER}
 	m20_baissiere_3_periodes     = m20_3&gt;m20_2 and m20_2&gt;m20_1 and m20_1 &gt; m20 ;
 	m7_en_dessous_m20_3_periodes = m7_2&lt;m20_2 and m7_1&lt;m20_1 and m7&lt;m20;
 	m7_devient_baissiere 	 =  m7_1&gt;m7_2 and m7_2&gt;m7_3 and m7&lt;m7_1 ;

	If ( m20_baissiere_3_periodes and m7_en_dessous_m20_3_periodes and m7_devient_baissiere) Then Begin
		UTLastSignalCode[timeframeIdx] = &quot;NXB&quot;;
		UTLastSignalDistance[timeframeIdx] = 0;
		signalFound = true;
	End;
	
	// D?tection XPH (croisement SAR/M20)
	Vars: sar_cross_m20_up(false), sar_cross_m20_down(false);

	sar_cross_m20_up = (UTData[timeframeIdx, IDX_SAR][1] &gt; UTData[timeframeIdx, IDX_M20][1] AND 
	                    UTData[timeframeIdx, IDX_SAR] &lt; UTData[timeframeIdx, IDX_M20]);
	sar_cross_m20_down = (UTData[timeframeIdx, IDX_SAR][1] &lt; UTData[timeframeIdx, IDX_M20][1] AND 
	                      UTData[timeframeIdx, IDX_SAR] &gt; UTData[timeframeIdx, IDX_M20]);

	If sar_cross_m20_up Then Begin
	    UTLastSignalCode[timeframeIdx] = &quot;XPH&quot;;
	    UTLastSignalDistance[timeframeIdx] = 0;
	    signalFound = true;
	End
	Else If sar_cross_m20_down Then Begin
	    UTLastSignalCode[timeframeIdx] = &quot;XPB&quot;;
	    UTLastSignalDistance[timeframeIdx] = 0;
	    signalFound = true;
	End;
    //End;
    
    {Si aucun nouveau signal, incrementer la distance}
    If NOT signalFound AND UTLastSignalDistance[timeframeIdx] &lt; 9999 Then
        UTLastSignalDistance[timeframeIdx] = UTLastSignalDistance[timeframeIdx] + 1;
    
    {===========================================================}
    {     MODULE 2.3: IDENTIFICATION DES SUPPORTS/RESISTANCES   }
    {===========================================================}
    
    {Remplir le tableau des indicateurs une seule fois}
    IndicatorsValueArray[timeframeIdx, 1, 1] = UTData[timeframeIdx, IDX_M7];
    IndicatorsNameArray[timeframeIdx, 1, 1] = &quot;M7-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 1, 2] = IFF(UTData[timeframeIdx, IDX_M7] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 2, 1] = UTData[timeframeIdx, IDX_M20];
    IndicatorsNameArray[timeframeIdx, 2, 1] = &quot;M20-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 2, 2] = IFF(UTData[timeframeIdx, IDX_M20] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 3, 1] = UTData[timeframeIdx, IDX_BBH];
    IndicatorsNameArray[timeframeIdx, 3, 1] = &quot;U-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 3, 2] = IFF(UTData[timeframeIdx, IDX_BBH] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 4, 1] = UTData[timeframeIdx, IDX_BBL];
    IndicatorsNameArray[timeframeIdx, 4, 1] = &quot;L-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 4, 2] = IFF(UTData[timeframeIdx, IDX_BBL] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 5, 1] = UTData[timeframeIdx, IDX_SAR];
    IndicatorsNameArray[timeframeIdx, 5, 1] = &quot;SAR-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 5, 2] = IFF(UTData[timeframeIdx, IDX_SAR] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 6, 1] = UTData[timeframeIdx, IDX_OGGY1];
    IndicatorsNameArray[timeframeIdx, 6, 1] = &quot;O1-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 6, 2] = IFF(UTData[timeframeIdx, IDX_OGGY1] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 7, 1] = UTData[timeframeIdx, IDX_OGGY2];
    IndicatorsNameArray[timeframeIdx, 7, 1] = &quot;O2-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 7, 2] = IFF(UTData[timeframeIdx, IDX_OGGY2] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 8, 1] = UTData[timeframeIdx, IDX_OGGY3];
    IndicatorsNameArray[timeframeIdx, 8, 1] = &quot;O3-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 8, 2] = IFF(UTData[timeframeIdx, IDX_OGGY3] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 9, 1] = UTData[timeframeIdx, IDX_JACK1];
    IndicatorsNameArray[timeframeIdx, 9, 1] = &quot;J1-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 9, 2] = IFF(UTData[timeframeIdx, IDX_JACK1] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 10, 1] = UTData[timeframeIdx, IDX_JACK2];
    IndicatorsNameArray[timeframeIdx, 10, 1] = &quot;J2-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 10, 2] = IFF(UTData[timeframeIdx, IDX_JACK2] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 11, 1] = UTData[timeframeIdx, IDX_JACK3];
    IndicatorsNameArray[timeframeIdx, 11, 1] = &quot;J3-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 11, 2] = IFF(UTData[timeframeIdx, IDX_JACK3] &gt; currentPrice, 1, -1);
    
    {Calcul du ClosestSupport et ClosestResistance avec v?rifications}
    Arrays: supports[15](0), resistances[15](0);
    supportCounter = 0;
    resistanceCounter = 0;

    For indicatorIdx = 1 to 11 Begin
        If indicatorIdx &lt;= 11 AND 
           IndicatorsValueArray[timeframeIdx, indicatorIdx, 2] &lt; 0 AND 
           IndicatorsValueArray[timeframeIdx, indicatorIdx, 1] &gt; 0 AND
           supportCounter &lt; 14 Then Begin
            supportCounter = supportCounter + 1;
            supports[supportCounter] = IndicatorsValueArray[timeframeIdx, indicatorIdx, 1];
        End
        Else If indicatorIdx &lt;= 11 AND
                IndicatorsValueArray[timeframeIdx, indicatorIdx, 2] &gt; 0 AND
                IndicatorsValueArray[timeframeIdx, indicatorIdx, 1] &gt; 0 AND
                resistanceCounter &lt; 14 Then Begin
            resistanceCounter = resistanceCounter + 1;
            resistances[resistanceCounter] = IndicatorsValueArray[timeframeIdx, indicatorIdx, 1];
        End;
    End;
    
    {Trouver les plus proches avec v?rifications de limites}
    If supportCounter &gt; 0 Then Begin
        minSupportValue = supports[1];
        For indicatorIdx = 2 to supportCounter Begin
            If indicatorIdx &lt;= supportCounter AND indicatorIdx &lt;= 14 Then Begin
                If supports[indicatorIdx] &gt; minSupportValue Then
                    minSupportValue = supports[indicatorIdx];
            End;
        End;
        UTData[timeframeIdx, IDX_CLOSEST_SUPPORT] = minSupportValue;
    End
    Else
        UTData[timeframeIdx, IDX_CLOSEST_SUPPORT] = 0;

    If resistanceCounter &gt; 0 Then Begin
        minResistanceValue = resistances[1];
        For indicatorIdx = 2 to resistanceCounter Begin
            If indicatorIdx &lt;= resistanceCounter AND indicatorIdx &lt;= 14 Then Begin
                If resistances[indicatorIdx] &lt; minResistanceValue Then
                    minResistanceValue = resistances[indicatorIdx];
            End;
        End;
        UTData[timeframeIdx, IDX_CLOSEST_RESISTANCE] = minResistanceValue;
    End
    Else
        UTData[timeframeIdx, IDX_CLOSEST_RESISTANCE] = 0;
End;

{===========================================================}
{           MODULE 3: GRANDE FENETRE ET AGREGATION          }
{===========================================================}

{Initialisation des variables et tableaux}
Vars: 
    supportIdx(0), resistanceIdx(0), allIndicatorsIdx(0), 
    utIdx(0), checkIdx(0), pdh(0), pdl(0), o1(0), c1(0), levelIdx (0);

{R?initialisation des tableaux}
For checkIdx = 1 to 100 Begin
    GF_Supports[checkIdx] = 0;
    GF_Resistances[checkIdx] = 0;
    GF_AllIndicatorsValue[checkIdx] = 0;
    GF_AllIndicatorsName[checkIdx] = &quot;&quot;;
End;

{Obtenir les donn?es du jour pr?c?dent}
OHLCPeriodsAgo(2,1, o1, pdh, pdl, c1);

{Remplissage des tableaux GF}
supportIdx = 0;
resistanceIdx = 0;
allIndicatorsIdx = 0;

For utIdx = TF_1 to TF_6 Begin
    For indicatorIdx = 1 to 11 Begin
        If IndicatorsValueArray[utIdx, indicatorIdx, 1] &gt; 0 AND allIndicatorsIdx &lt; 90 Then Begin
            allIndicatorsIdx = allIndicatorsIdx + 1;
            GF_AllIndicatorsValue[allIndicatorsIdx] = IndicatorsValueArray[utIdx, indicatorIdx, 1];
            GF_AllIndicatorsName[allIndicatorsIdx] = IndicatorsNameArray[utIdx, indicatorIdx, 1];
            
            If IndicatorsValueArray[utIdx, indicatorIdx, 2] &lt; 0 AND supportIdx &lt; 95  Then Begin
                supportIdx = supportIdx + 1;
                GF_Supports[supportIdx] = IndicatorsValueArray[utIdx, indicatorIdx, 1];
            End
            Else If IndicatorsValueArray[utIdx, indicatorIdx, 2] &gt; 0 AND resistanceIdx &lt; 95 Then Begin
                resistanceIdx = resistanceIdx + 1;
                GF_Resistances[resistanceIdx] = IndicatorsValueArray[utIdx, indicatorIdx, 1];
            End;
        End;
    End;
End;

{Ajout des niveaux suppl?mentaires avec classification automatique}
Arrays: levelValues[7](0), levelNames[7](&quot;&quot;), levelTypes[7](0);

{Initialiser les tableaux de niveaux}
levelValues[1] = pdh;    				levelNames[1] = &quot;PDH&quot;;
levelValues[2] = pdl;    	 		  	levelNames[2] = &quot;PDL&quot;; 
levelValues[3] = highW(1) ;   		 	levelNames[3] = &quot;PWH&quot;;
levelValues[4] = LowW(1)  ;				levelNames[4] = &quot;PWL&quot;;
levelValues[5] = HighM(1) ;	       		levelNames[5] = &quot;PMH&quot;;
levelValues[6] = LowM(1)  ;        		levelNames[6] = &quot;PML&quot;;
levelValues[7] = Highest(High of Data(6),50);    levelNames[7] = &quot;ATH&quot;;

{Boucle pour traiter tous les niveaux}
For levelIdx = 1 to 7 Begin
    If allIndicatorsIdx &lt; 95 AND levelValues[levelIdx] &gt; 0 Then Begin
        {Ajouter au tableau global}
        allIndicatorsIdx = allIndicatorsIdx + 1;
        GF_AllIndicatorsValue[allIndicatorsIdx] = levelValues[levelIdx];
        GF_AllIndicatorsName[allIndicatorsIdx] = levelNames[levelIdx];
        
        {Classification automatique}
        If levelValues[levelIdx] &gt; currentPrice Then Begin
            {R?sistance}
            If resistanceIdx &lt; 95 Then Begin
                resistanceIdx = resistanceIdx + 1;
                GF_Resistances[resistanceIdx] = levelValues[levelIdx];
            End;
        End
        Else If levelValues[levelIdx] &lt; currentPrice Then Begin
            {Support}
            If supportIdx &lt; 95 Then Begin
                supportIdx = supportIdx + 1;
                GF_Supports[supportIdx] = levelValues[levelIdx];
            End;
        End;
    End;
End;


{Tri des tableaux avec v?rification de limites}
If supportIdx &gt; 1 Then
    Array_sort(GF_Supports, 1, supportIdx, false);
If resistanceIdx &gt; 1 Then
    Array_sort(GF_Resistances, 1, resistanceIdx, true);

{Calcul des plus proches globaux}
If supportIdx &gt; 0 Then
    GF_ClosestSupport = GF_Supports[1]
Else
    GF_ClosestSupport = 0;
    
If resistanceIdx &gt; 0 Then
    GF_ClosestResistance = GF_Resistances[1]
Else
    GF_ClosestResistance = 0;

{Detection des clusters avec v?rifications de limites}
SupportClusterCount = 0;
ResistanceClusterCount = 0;

If supportIdx &gt; 1 AND GF_ClosestSupport &gt; 0 Then Begin
    For checkIdx = 1 to supportIdx Begin
        If checkIdx &lt;= supportIdx AND checkIdx &lt;= 100 Then Begin
            If absvalue(GF_ClosestSupport - GF_Supports[checkIdx]) &lt;= param_ClusterPips Then
                SupportClusterCount = SupportClusterCount + 1;
        End;
    End;
End;

If resistanceIdx &gt; 1 AND GF_ClosestResistance &gt; 0 Then Begin
    For checkIdx = 1 to resistanceIdx Begin
        If checkIdx &lt;= resistanceIdx AND checkIdx &lt;= 100 Then Begin
            If absvalue(GF_Resistances[checkIdx] - GF_ClosestResistance) &lt;= param_ClusterPips Then
                ResistanceClusterCount = ResistanceClusterCount + 1;
        End;
    End;
End;

GF_isSupportCluster = (SupportClusterCount &gt; 3);
GF_isResistanceCluster = (ResistanceClusterCount &gt; 3);



{===========================================================}
{          MODULE 4: DETECTION DES SCENARIOS TRADING        }
{===========================================================}

Vars: buy_condition (false), UT1_Haussiere (false), UT2_Haussiere (false), UT3_Haussiere (false), UT4_Haussiere (false), UT5_Haussiere (false), UT6_Haussiere (false),
	UT1_Baissiere (false), UT2_Baissiere (false), UT3_Baissiere (false), UT4_Baissiere (false), UT5_Baissiere (false), UT6_Baissiere (false),
	UT1_LowSignal (false), UT2_LowSignal (false), UT3_LowSignal (false), UT4_LowSignal (false), UT5_LowSignal (false), UT6_LowSignal (false),
	cond_1_UT_Haussiere(false), cond_UT12_nonBaissiere(false), cond_noLowSignal(false), cond_ut_sup_haussiere (false), cond_no_trading_range(false), cond_aucune_ut_baissiere(false), cond_noContreSignal(false), cond_entree_nominale(false), 
	buy_uc1 (false), buy_other_uc (false), 	short_uc1b (false), short_other_uc (false), supertrend (0), st(0);
	

// On met en input le nb de barres permettant de valider un signal rcent (en nb de barres de l&#39;UT du graph en cours)
Inputs:
	nbBarRecentSignal_tf1 (2), nbBarRecentSignal_tf2 (4), nbBarRecentSignal_tf3 (16), nbBarRecentSignal_tf4 (96), nbBarRecentSignal_tf5 (480), nbBarRecentSignal_tf6 (1920);
	

{R?initialisation}
GF_CodeScenarioLong = &quot;&quot;;
GF_PossibleScenarioLong = &quot;&quot;;
GF_CodeScenarioShort = &quot;&quot;;
GF_PossibleScenarioShort = &quot;&quot;;

{Calcul des signaux r?cents}
GF_SignauxHaussiers = &quot;&quot;;
GF_SignauxBaissiers = &quot;&quot;;
GF_NbSignauxHaussiersRecents = 0;
GF_NbSignauxBaissiersRecents = 0;

// reinits a chaque barre
buy_condition=false;
UT1_Haussiere= UTBollPhase[1]=&quot;P2H&quot; or UTBollPhase[1]=&quot;P3H&quot;; 
UT2_Haussiere= UTBollPhase[2]=&quot;P2H&quot; or UTBollPhase[2]=&quot;P3H&quot;; 
UT3_Haussiere= UTBollPhase[3]=&quot;P2H&quot; or UTBollPhase[3]=&quot;P3H&quot;;
UT4_Haussiere= UTBollPhase[4]=&quot;P2H&quot; or UTBollPhase[4]=&quot;P3H&quot;;
UT5_Haussiere= UTBollPhase[5]=&quot;P2H&quot; or UTBollPhase[5]=&quot;P3H&quot;;
UT6_Haussiere= UTBollPhase[6]=&quot;P2H&quot; or UTBollPhase[6]=&quot;P3H&quot;;

UT1_Baissiere= UTBollPhase[1]=&quot;P2B&quot; or UTBollPhase[1]=&quot;P3B&quot;;
UT2_Baissiere= UTBollPhase[2]=&quot;P2B&quot; or UTBollPhase[2]=&quot;P3B&quot;; 
UT3_Baissiere= UTBollPhase[3]=&quot;P2B&quot; or UTBollPhase[3]=&quot;P3B&quot;; 
UT4_Baissiere= UTBollPhase[4]=&quot;P2B&quot; or UTBollPhase[4]=&quot;P3B&quot;; 
UT5_Baissiere= UTBollPhase[5]=&quot;P2B&quot; or UTBollPhase[5]=&quot;P3B&quot;; 
UT6_Baissiere= UTBollPhase[6]=&quot;P2B&quot; or UTBollPhase[6]=&quot;P3B&quot;;

UT1_LowSignal= (UTLastSignalCode[1]=&quot;XB&quot; or UTLastSignalCode[1]=&quot;xB&quot; or UTLastSignalCode[1]=&quot;NXB&quot; or UTLastSignalCode[1]=&quot;XPB&quot; ) and UTLastSignalDistance[1]&lt;=nbBarRecentSignal_tf1;
UT2_LowSignal= (UTLastSignalCode[2]=&quot;XB&quot; or UTLastSignalCode[2]=&quot;xB&quot; or UTLastSignalCode[2]=&quot;NXB&quot; or UTLastSignalCode[2]=&quot;XPB&quot; ) and UTLastSignalDistance[2]&lt;=nbBarRecentSignal_tf2;
UT3_LowSignal= (UTLastSignalCode[3]=&quot;XB&quot; or UTLastSignalCode[3]=&quot;xB&quot; or UTLastSignalCode[3]=&quot;NXB&quot; or UTLastSignalCode[3]=&quot;XPB&quot; ) and UTLastSignalDistance[3]&lt;=nbBarRecentSignal_tf3;
UT4_LowSignal= (UTLastSignalCode[4]=&quot;XB&quot; or UTLastSignalCode[4]=&quot;xB&quot; or UTLastSignalCode[4]=&quot;NXB&quot; or UTLastSignalCode[4]=&quot;XPB&quot; ) and UTLastSignalDistance[4]&lt;=nbBarRecentSignal_tf4;
UT5_LowSignal= (UTLastSignalCode[5]=&quot;XB&quot; or UTLastSignalCode[5]=&quot;xB&quot; or UTLastSignalCode[5]=&quot;NXB&quot; or UTLastSignalCode[5]=&quot;XPB&quot; ) and UTLastSignalDistance[5]&lt;=nbBarRecentSignal_tf5;
UT6_LowSignal= (UTLastSignalCode[6]=&quot;XB&quot; or UTLastSignalCode[6]=&quot;xB&quot; or UTLastSignalCode[6]=&quot;NXB&quot; or UTLastSignalCode[6]=&quot;XPB&quot; ) and UTLastSignalDistance[6]&lt;=nbBarRecentSignal_tf6;


cond_1_UT_Haussiere= UT3_Haussiere or UT4_Haussiere or UT5_Haussiere or UT6_Haussiere;
cond_UT12_nonBaissiere= NOT (UT1_Baissiere or UT2_Baissiere);
cond_noLowSignal= NOT (UT1_LowSignal or UT2_LowSignal or UT3_LowSignal or UT4_LowSignal or UT5_LowSignal or UT6_LowSignal);
cond_ut_sup_haussiere= UT2_Haussiere ;
cond_no_trading_range = not (UTBollPhase[1]=&quot;P1&quot; or UTBollPhase[1]=&quot;P4&quot;);
cond_aucune_ut_baissiere= not (UT1_Baissiere or UT2_Baissiere or UT3_Baissiere or UT4_Baissiere or UT5_Baissiere or UT6_Baissiere);
cond_noContreSignal= GF_CodeScenarioLong&lt;&gt;&quot;&quot; and GF_CodeScenarioShort=&quot;&quot;;
supertrend= 0 ; //SuperTrendOliverSeban(10, 3, st);


cond_entree_nominale= cond_1_UT_Haussiere 
			 and cond_UT12_nonBaissiere 
			 // and cond_noLowSignal 
			 and GF_isSupportCluster 
			 and cond_ut_sup_haussiere ;
			 // and cond_aucune_ut_baissiere;

{ Variables pour conditions P2H avec filtre dur?e }
Vars:
    UT1_P2H_ValidDuration(false),
    UT2_P2H_ValidDuration(false),
    UT3_P2H_ValidDuration(false),
    anyUT_P2H_ValidDuration(false);

{ V?rifier si les timeframes ont une dur?e P2H dans la plage acceptable }
UT1_P2H_ValidDuration = UTBollPhase[1] = &quot;P2H&quot; AND 
                        UTDureeP2H[1] &gt;= param_MinDureeP2H AND 
                        UTDureeP2H[1] &lt;= param_MaxDureeP2H;

UT2_P2H_ValidDuration=  UTBollPhase[2] = &quot;P2H&quot; AND 
                        UTDureeP2H[2] &gt;= param_MinDureeP2H AND 
                        UTDureeP2H[2] &lt;= param_MaxDureeP2H; 


// Detection UC2 sur UT1 ou UT2:
if UTLastSignalCode[1]=&quot;XH&quot; or UTLastSignalCode[1]=&quot;NXH&quot; or UTLastSignalCode[1]=&quot;XPH&quot; and UTLastSignalDistance[1]&lt;nbBarRecentSignal_tf1 Then
	GF_CodeScenarioLong=&quot;UC2&quot;;
if UTLastSignalCode[2]=&quot;XH&quot; or UTLastSignalCode[2]=&quot;NXH&quot; or UTLastSignalCode[2]=&quot;XPH&quot; and UTLastSignalDistance[2]&lt;nbBarRecentSignal_tf2 Then
	GF_CodeScenarioLong=&quot;UC2&quot;;

// Detection UC1 P2H sur UT1:
if UTData[1, IDX_BBH]&gt;UTData[1, IDX_BBH][1] and UTData[1, IDX_BBL]&lt;UTData[1, IDX_BBL][1] and UTData[1, IDX_M7]&gt;UTData[1, IDX_M7][1] and UT1_P2H_ValidDuration Then // and (UTBollPhase[1]=&quot;P1&quot; or UTBollPhase[1]=&quot;P4&quot;) Then
	GF_CodeScenarioLong=&quot;UC1&quot;;
// Detection UC1 P2H sur UT2:
if UTData[2, IDX_BBH]&gt;UTData[2, IDX_BBH][4] and UTData[2, IDX_BBL]&lt;UTData[2, IDX_BBL][4] and UTData[2, IDX_M7]&gt;UTData[2, IDX_M7][4] and UT2_P2H_ValidDuration Then //and (UTBollPhase[2]=&quot;P1&quot; or UTBollPhase[2]=&quot;P4&quot;)Then
	GF_CodeScenarioLong=&quot;UC1&quot;;




buy_uc1 = param_uc1=1 and GF_CodeScenarioLong=&quot;UC1&quot; 
 			and (  PatternNeutralFast(LONG_UC1_PtnNeut_Yes,ohlcvalues) ) //or PatternNeutralFast(LONG_UC1_PtnNeut_Yes2,ohlcvalues) ) ;
 			and (PatternNeutralFast(LONG_UC1_PtnNeut_No,ohlcvalues)=False)
                     and PatternDirectionalFast(LONG_UC1_PtnDir_No,ohlcvalues)=false
                     and PatternDirectionalFast(LONG_UC1_PtnDir_Yes,ohlcvalues) ;
// and ( (Not UT2_LowSignal and UTLastSignalDistance[2]&lt;nbBarRecentSignal_tf2 ) or  (Not UT3_LowSignal and UTLastSignalDistance[3]&lt;nbBarRecentSignal_tf3 ) ) ;

	   
buy_other_uc=  param_uc2=1 and GF_CodeScenarioLong&lt;&gt;&quot;&quot; and GF_CodeScenarioLong&lt;&gt;&quot;UC1&quot; and cond_entree_nominale and cond_no_trading_range //and supertrend&lt;close 
      		and PatternNeutralFast(LONG_UC2_PtnNeut_Yes,ohlcvalues) and (PatternNeutralFast(LONG_UC2_PtnNeut_No,ohlcvalues)=False)
              and PatternDirectionalFast(LONG_UC2_PtnDir_No,ohlcvalues)=false ;

Vars:
	current_objective (0), objective_1 (0), objective_2(0), current_SL(0);

objective_1=  maxlist(GF_ClosestResistance, close+param_TPLong);

If arraysize(GF_Resistances)&gt;1 Then
	objective_2= maxlist(GF_Resistances[2], close+param_TPLong*1.5)
Else
	objective_2=0;
	

//if Close-GF_ClosestSupport-param_ClusterPips &gt;0 Then
// Ajouter la condition suivante: eviter Avril et surtout Aout : (MonthFromDateTime(DateTime) &lt;&gt;8 or MonthFromDateTime(DateTime) &lt;&gt;4)  and 
buy_condition =  Month(Date)&lt;&gt;noTradingMonth and dayofweek(Date)&lt;&gt;noTradingDay and (buy_uc1 or buy_other_uc) and GF_isSupportCluster and  adx(7)&gt;20 and globalTradingEnabled;


	 		


{===========================================================}
{          MODULE 6: GESTION DES ENTREES ET SORTIES         }
{===========================================================}
Vars:
	TradingWindow (false), WeekClosure (false), DayClosure (false), exit_EndSession_condition(false), exit_uc1 (false), current_trade_scenario (&quot;&quot;);
	



WeekClosure= param_CloseOnFriday=1 and dayofweekfromdatetime(currentdate)=5 ;
DayClosure= (param_ExitOnSessionClose=1) ;



if param_exit_uc1 = 1 Then Begin
	exit_uc1 =  UTData[1, IDX_BBH][1]&gt;UTData[1, IDX_BBH][2] and UTData[1, IDX_BBL][1]&lt;UTData[1, IDX_BBL][2] and UTData[1, IDX_BBH]&lt;UTData[1, IDX_BBH][1];
End
else
    if param_exit_uc1 = 2 Then begin
        exit_uc1 = UTData[1, IDX_SAR] &lt; UTData[1, IDX_SAR][1] and UTData[1, IDX_SAR][1]&gt; close[1];
    end
    else 
        if param_exit_uc1 = 3 Then begin
            exit_uc1 = close &lt; UTData[1, IDX_M20] and close[1]&gt;UTData[1, IDX_M20][1];
        end
        else
            if param_exit_uc1=0 Then begin
                exit_uc1=false;
            end;
            


exit_EndSession_condition= WeekClosure or DayClosure ;

	
TradingWindow= tw(session_StartTime, session_EndTime) ;
 {
	or (Time&lt;session_PauseStart2 or Time&gt;session_PauseEnd2)
	or (Time&lt;session_PauseStart3 or Time&gt;session_PauseEnd3)
	);
}

if marketposition=0 and buy_condition //and TradingWindow
  and (Time&lt;session_PauseStart1 or Time&gt;session_PauseEnd1) 
  and (Time&lt;session_PauseStart2 or Time&gt;session_PauseEnd2)  Then // and TradingWindow and dayofweek(date) &lt;&gt; 5 Then
	Begin
		buy (GF_CodeScenarioLong) myContract Contracts next bar at market;
		current_objective= objective_1;
		current_trade_scenario=GF_CodeScenarioLong;
	End;
 

//setstoploss_pt(1000);//-param_ClusterPips);
//setprofittarget_pt (200);


// Gestion des TP Partiels et SL:

// Si on est en position avec 2 contrats alors on met le TP1  Objectif 1 et on monte le SL a BE
if MarketPosition = 1 and currentcontracts=myContract and globalTradingEnabled then
	Begin
	    Sell(&quot;TP1_50pct&quot;) floor(myContract/2) contracts next bar at current_objective limit;
	    setstoploss_pt(param_SLLong);
	End;

// On change l&#39;objectif du trade si on est en position apres une prise de profit partielle d&#39;un contrat. 
// On affecte alors le nouvel objectif calcule (objective_1)
if marketposition = 1 and currentContracts&lt;myContract and currentContracts[1]=myContract  and globalTradingEnabled then
	current_objective=objective_1;

// Si on est en position avec un seul contrat, c&#39;est qu&#39;on vise le TP2 
if MarketPosition = 1 and currentcontracts=floor(myContract/2)  and globalTradingEnabled then
	Begin
	   //current_objective=100;
	   settrailingstop_pt(param_TrailingSL);
	   //Sell(&quot;TP2_50pct&quot;) 1 contracts next bar at current_objective limit;
	   //setstoploss_pt(absvalue(close-entryprice));
	   
	End;

//set ppfloor and ppratio to protect profit
Inputs:
    ppfloor(6000),    // Seuil de profit minimum avant d&#39;activer la sortie
    ppratio(0.80);    // Ratio de profit ? conserver (ex: 60%)

if MaxPositionProfit &gt;= ppfloor  and globalTradingEnabled then
begin
    // Si le profit latent est retomb? sous 60% du profit maximum atteint, on sort
    if (OpenPositionProfit / MaxPositionProfit) &lt; ppratio then
    begin
        Sell next bar at market;
        BuyToCover next bar at market;
    end;
end;


// Exit conditions
if marketposition=1 and exit_EndSession_condition and globalTradingEnabled  Then
	Begin
	setexitonclose;
	exit_EndSession_condition=false;
	End;
  
if marketposition=1 and exit_uc1 and current_trade_scenario=&quot;UC1&quot;  and globalTradingEnabled Then Begin
	Sell (&quot;Exit condition&quot;) currentcontracts contracts next bar at market;
	current_trade_scenario=&quot;&quot;;
End;
// setprofittarget_pt (objective_1);


{===========================================================}
{          MODULE 5: DISPLAY CONFIGURATION COMPL?TE        }
{===========================================================}

Vars:
    text_id(0), text_id1(0), text_id2(0), text_id3(0), 
    line_to_display(&quot;&quot;), supports_to_display(&quot;&quot;), resistances_to_display(&quot;&quot;),
    GF_isSupportCluster_String(&quot;&quot;), GF_isResistanceCluster_String(&quot;&quot;),
    srName(&quot;&quot;), idx_findSRName(0);

{Affichage des signaux r?cents}
If UTLastSignalDistance[TF_1] &gt;= nbBarRecentSignal_tf1 Then
    text_delete(text_id1);
    
If UTLastSignalCode[TF_1] &lt;&gt; &quot;NC&quot; AND UTLastSignalDistance[TF_1] &lt; nbBarRecentSignal_tf1 Then
    text_id1 = text_new(date, time, high, UTLastSignalCode[TF_1]);

If LastBarOnChart and DisplayATSConfiguration=1 Then Begin
    {Pr?paration des cha?nes pour les supports}
    srName = &quot;&quot;;
    supports_to_display = &quot;&quot;;
    
    For timeframeIdx = 1 to supportIdx Begin
        If GF_Supports[timeframeIdx] &lt;&gt; 0 AND timeframeIdx &lt;= supportIdx Then Begin
            idx_findSRName = array_indexof(GF_AllIndicatorsValue, GF_Supports[timeframeIdx]);
            If idx_findSRName &gt; 0 AND idx_findSRName &lt;= allIndicatorsIdx Then Begin
                srName = GF_AllIndicatorsName[idx_findSRName];
                supports_to_display = supports_to_display + srName + &quot; : &quot; + NumToStr(GF_Supports[timeframeIdx],0) + NewLine;
            End;
        End;
    End;
    
    {Pr?paration des cha?nes pour les r?sistances}
    srName = &quot;&quot;;
    resistances_to_display = &quot;&quot;;
    
    For timeframeIdx = 1 to resistanceIdx Begin
        If GF_Resistances[timeframeIdx] &lt;&gt; 0 AND timeframeIdx &lt;= resistanceIdx Then Begin
            idx_findSRName = array_indexof(GF_AllIndicatorsValue, GF_Resistances[timeframeIdx]);
            If idx_findSRName &gt; 0 AND idx_findSRName &lt;= allIndicatorsIdx Then Begin
                srName = GF_AllIndicatorsName[idx_findSRName];
                resistances_to_display = resistances_to_display + srName + &quot; : &quot; + NumToStr(GF_Resistances[timeframeIdx],0) + NewLine;
            End;
        End;
    End;

    {Pr?paration des cha?nes de cluster}
    If GF_isSupportCluster Then
        GF_isSupportCluster_String = &quot;YES&quot;
    Else 
        GF_isSupportCluster_String = &quot;NO&quot;;

    If GF_isResistanceCluster Then
        GF_isResistanceCluster_String = &quot;YES&quot;
    Else 
        GF_isResistanceCluster_String = &quot;NO&quot;;
        
    {Suppression de l&#39;ancien tableau}
    If text_id &gt;= 0 Then
        text_delete(text_id);

    {Tableau de configuration complet - RESTAUR?}
    line_to_display = &quot;&quot;;
    
    line_to_display = line_to_display + &quot;|            |     GF          |      UT1      |      UT2      |      UT3      |      UT4      |      UT5      |      UT6      |&quot; + NewLine;
    line_to_display = line_to_display + &quot;| M7         |     N/A         |     &quot; + NumToStr(UTData[TF_1, IDX_M7],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_M7],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_M7],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_M7],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_M7],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_M7],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| M20        |     N/A         |     &quot; + NumToStr(UTData[TF_1, IDX_M20],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_M20],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_M20],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_M20],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_M20],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_M20],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| BBH        |     N/A         |     &quot; + NumToStr(UTData[TF_1, IDX_BBH],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_BBH],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_BBH],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_BBH],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_BBH],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_BBH],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| BBL        |     N/A         |     &quot; + NumToStr(UTData[TF_1, IDX_BBL],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_BBL],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_BBL],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_BBL],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_BBL],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_BBL],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| SAR        |     N/A         |     &quot; + NumToStr(UTData[TF_1, IDX_SAR],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_SAR],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_SAR],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_SAR],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_SAR],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_SAR],0) + &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| OGY1       |     N/A         |     &quot; + NumToStr(UTData[TF_1, IDX_OGGY1],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_OGGY1],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_OGGY1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_OGGY1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_OGGY1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_OGGY1],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| OGY2       |     N/A         |     &quot; + NumToStr(UTData[TF_1, IDX_OGGY2],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_OGGY2],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_OGGY2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_OGGY2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_OGGY2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_OGGY2],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| OGY3       |     N/A         |     &quot; + NumToStr(UTData[TF_1, IDX_OGGY3],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_OGGY3],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_OGGY3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_OGGY3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_OGGY3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_OGGY3],0) + &quot;   |     &quot; + NewLine;
      
    line_to_display = line_to_display + &quot;| JAK1       |     N/A         |     &quot; + NumToStr(UTData[TF_1, IDX_JACK1],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_JACK1],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_JACK1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_JACK1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_JACK1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_JACK1],0) + &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| JAK2       |     N/A         |     &quot; + NumToStr(UTData[TF_1, IDX_JACK2],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_JACK2],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_JACK2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_JACK2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_JACK2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_JACK2],0) + &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| JAK3       |     N/A         |     &quot; + NumToStr(UTData[TF_1, IDX_JACK3],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_JACK3],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_JACK3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_JACK3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_JACK3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_JACK3],0) + &quot;   |     &quot; + NewLine;
      
    line_to_display = line_to_display + &quot;| Phase      |     N/A         |     &quot; + UTBollPhase[TF_1] + &quot;      |     &quot; + UTBollPhase[TF_2] + &quot;     |     &quot;
      + UTBollPhase[TF_3] + &quot;     |     &quot; + UTBollPhase[TF_4] + &quot;     |     &quot; + UTBollPhase[TF_5] + &quot;     |     &quot; + UTBollPhase[TF_6] + &quot;     |     &quot; + NewLine;
      
    line_to_display = line_to_display + &quot;| Sup.       |    &quot; + NumToStr(GF_ClosestSupport,0) + &quot;     |     &quot; + NumToStr(UTData[TF_1, IDX_CLOSEST_SUPPORT],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_CLOSEST_SUPPORT],0)+ &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Clust      |    &quot; + GF_isSupportCluster_String + &quot;     |     N/A    |     N/A   |     &quot;
      + &quot;N/A   |     N/A   |     N/A   |     N/A   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Res.       |    &quot; + NumToStr(GF_ClosestResistance,0) + &quot;     |     &quot; + NumToStr(UTData[TF_1, IDX_CLOSEST_RESISTANCE],0) + &quot;    |     &quot; + NumToStr(UTData[TF_2, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_3, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot; + NumToStr(UTData[TF_4, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot; + NumToStr(UTData[TF_5, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot; + NumToStr(UTData[TF_6, IDX_CLOSEST_RESISTANCE],0)+ &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Clust      |    &quot; + GF_isResistanceCluster_String + &quot;     |     N/A    |     N/A   |     &quot;
      + &quot;N/A   |     N/A   |     N/A   |     N/A   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Sign       |    N/A      |     &quot; + UTLastSignalCode[TF_1] + &quot;    |     &quot; + UTLastSignalCode[TF_2] + &quot;   |     &quot;
      + UTLastSignalCode[TF_3] + &quot;   |     &quot; + UTLastSignalCode[TF_4] + &quot;   |     &quot; + UTLastSignalCode[TF_5] + &quot;   |     &quot; + UTLastSignalCode[TF_6]+ &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Dist       |    N/A      |     &quot; + NumToStr(UTLastSignalDistance[TF_1],0) + &quot;    |     &quot; + NumToStr(UTLastSignalDistance[TF_2],0) + &quot;   |     &quot;
      + NumToStr(UTLastSignalDistance[TF_3],0) + &quot;   |     &quot; + NumToStr(UTLastSignalDistance[TF_4],0) + &quot;   |     &quot; + NumToStr(UTLastSignalDistance[TF_5],0) + &quot;   |     &quot; + NumToStr(UTLastSignalDistance[TF_6],0)+ &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + NewLine + &quot;SCENARIOS:&quot; + NewLine;
    line_to_display = line_to_display + &quot;Long: &quot; + GF_CodeScenarioLong + &quot; - &quot; + GF_PossibleScenarioLong + NewLine;
    line_to_display = line_to_display + &quot;Short: &quot; + GF_CodeScenarioShort + &quot; - &quot; + GF_PossibleScenarioShort + NewLine;

    text_id = text_new(date+1, time, high, line_to_display);

    {Affichage tableau des Supports et r?sistances - RESTAUR?}
    If text_id2 &gt; 0 Then
        text_delete(text_id2);

    If text_id3 &gt; 0 Then
        text_delete(text_id3);
        
    text_id2 = text_new(date, time, low, &quot;Resistances :&quot; + NewLine + resistances_to_display);
    text_id3 = text_new(date, time, currentPrice, &quot;Supports :&quot; + NewLine + supports_to_display);
End;

{ ============== TABLEAU DE BORD MULTI-HORIZONS ============== }
If LastBarOnChart AND DisplayPerfo = 1 Then Begin
    Vars: 
        multiHorizonDisplay(&quot;&quot;), 
        globalStatusColor(White),
        dailyStatusText(&quot;&quot;), weeklyStatusText(&quot;&quot;), monthlyStatusText(&quot;&quot;);
    
    { Pr?paration des textes de status }
    If dailyTradingEnabled Then 
        dailyStatusText = &quot;ACTIF&quot;
    Else 
        dailyStatusText = &quot;BLOQUE&quot;;
        
    If weeklyTradingEnabled Then 
        weeklyStatusText = &quot;ACTIF&quot;
    Else 
        weeklyStatusText = &quot;BLOQUE&quot;;
        
    If monthlyTradingEnabled Then 
        monthlyStatusText = &quot;ACTIF&quot;
    Else 
        monthlyStatusText = &quot;BLOQUE&quot;;
    
    { Construction du tableau }
    multiHorizonDisplay = &quot;=== PROFIT MULTI-HORIZONS ===&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Date: &quot; + NumToStr(Date, 0) + &quot; | Heure: &quot; + NumToStr(Time, 0) + NewLine ;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Total Net Profit: &quot; + NumToStr(NetProfit, 0)  + NewLine + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Contract Expiration Date: &quot; + datetostring(ExpirationDateFromVendor)  + NewLine + NewLine;

    
    { SECTION JOURNALIERE }
    multiHorizonDisplay = multiHorizonDisplay + &quot;--- JOURNALIER ---&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Profit: &quot; + NumToStr(dailyProfit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Limite: &quot; + NumToStr(param_DailyLossLimit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Trades: &quot; + NumToStr(dailyTradeCount, 0) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Status: &quot; + dailyStatusText + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Distance: &quot; + NumToStr(dailyProfit - param_DailyLossLimit, 2) + NewLine + NewLine;
    
    { SECTION HEBDOMADAIRE }
    multiHorizonDisplay = multiHorizonDisplay + &quot;--- HEBDOMADAIRE ---&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Profit: &quot; + NumToStr(weeklyProfit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Limite: &quot; + NumToStr(param_WeeklyLossLimit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Trades: &quot; + NumToStr(weeklyTradeCount, 0) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Status: &quot; + weeklyStatusText + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Distance: &quot; + NumToStr(weeklyProfit - param_WeeklyLossLimit, 2) + NewLine + NewLine;
    
    { SECTION MENSUELLE }
    multiHorizonDisplay = multiHorizonDisplay + &quot;--- MENSUEL ---&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Profit: &quot; + NumToStr(monthlyProfit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Limite: &quot; + NumToStr(param_MonthlyLossLimit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Trades: &quot; + NumToStr(monthlyTradeCount, 0) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Status: &quot; + monthlyStatusText + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Distance: &quot; + NumToStr(monthlyProfit - param_MonthlyLossLimit, 2) + NewLine + NewLine;
    
    { STATUS GLOBAL }
    multiHorizonDisplay = multiHorizonDisplay + &quot;=== STATUS GLOBAL ===&quot; + NewLine;
    If globalTradingEnabled Then Begin
        multiHorizonDisplay = multiHorizonDisplay + &quot;TRADING: AUTORISE&quot; + NewLine;
        globalStatusColor = Green;
    End
    Else Begin
        multiHorizonDisplay = multiHorizonDisplay + &quot;TRADING: SUSPENDU&quot; + NewLine;
        globalStatusColor = Red;
    End;
    
    { Affichage }
    Vars: multiHorizonTextId(0);
    If multiHorizonTextId &gt; 0 Then
        text_delete(multiHorizonTextId);
        
    multiHorizonTextId = text_new(date, time + 200, high + 100, multiHorizonDisplay);
    text_setcolor(multiHorizonTextId, globalStatusColor);
End;

{ 9. FONCTION DE DEBUG DETAILLEE }

{ ============== DEBUG MULTI-HORIZONS ============== }
If Mod(BarNumber, 200) = 0 Then Begin  // Debug toutes les 200 barres
    Print(&quot;=== DEBUG MULTI-HORIZONS ===&quot;);
    Print(&quot;Barre: &quot;, BarNumber, &quot; | Date: &quot;, Date, &quot; | Time: &quot;, Time);
    Print(&quot;NetProfit total: &quot;, NetProfit);
    Print(&quot;Starts - Jour: &quot;, dailyStartProfit, &quot; | Semaine: &quot;, weeklyStartProfit, &quot; | Mois: &quot;, monthlyStartProfit);
    Print(&quot;Profits - Jour: &quot;, dailyProfit, &quot; | Semaine: &quot;, weeklyProfit, &quot; | Mois: &quot;, monthlyProfit);
    Print(&quot;Status - Jour: &quot;, dailyTradingEnabled, &quot; | Semaine: &quot;, weeklyTradingEnabled, &quot; | Mois: &quot;, monthlyTradingEnabled);
    Print(&quot;GLOBAL: &quot;, globalTradingEnabled);
End;

{ 10. STATISTIQUES AVANCEES PAR HORIZON }

{ Variables pour statistiques d?taill?es }
Vars:
    { === STATISTIQUES JOURNALIERES === }
    dailyWinTrades(0), dailyLossTrades(0),
    dailyGrossProfit(0), dailyGrossLoss(0),
    dailyLargestWin(0), dailyLargestLoss(0),
    
    { === STATISTIQUES HEBDOMADAIRES === }
    weeklyWinTrades(0), weeklyLossTrades(0),
    weeklyGrossProfit(0), weeklyGrossLoss(0),
    weeklyLargestWin(0), weeklyLargestLoss(0),
    
    { === STATISTIQUES MENSUELLES === }
    monthlyWinTrades(0), monthlyLossTrades(0),
    monthlyGrossProfit(0), monthlyGrossLoss(0),
    monthlyLargestWin(0), monthlyLargestLoss(0);

{ Mise ? jour des statistiques lors des sorties }
If MarketPosition = 0 AND MarketPosition[1] &lt;&gt; 0 Then Begin
    lastTradeExitProfit = NetProfit - NetProfit[1];
    
    { === STATS JOURNALIERES === }
    If Date = lastDailyResetDate Then Begin
        If lastTradeExitProfit &gt; 0 Then Begin
            dailyWinTrades = dailyWinTrades + 1;
            dailyGrossProfit = dailyGrossProfit + lastTradeExitProfit;
            If lastTradeExitProfit &gt; dailyLargestWin Then
                dailyLargestWin = lastTradeExitProfit;
        End
        Else If lastTradeExitProfit &lt; 0 Then Begin
            dailyLossTrades = dailyLossTrades + 1;
            dailyGrossLoss = dailyGrossLoss + lastTradeExitProfit;
            If lastTradeExitProfit &lt; dailyLargestLoss Then
                dailyLargestLoss = lastTradeExitProfit;
        End;
    End;
    
    { === STATS HEBDOMADAIRES === }
    If Date &gt;= lastWeeklyResetDate Then Begin
        If lastTradeExitProfit &gt; 0 Then Begin
            weeklyWinTrades = weeklyWinTrades + 1;
            weeklyGrossProfit = weeklyGrossProfit + lastTradeExitProfit;
            If lastTradeExitProfit &gt; weeklyLargestWin Then
                weeklyLargestWin = lastTradeExitProfit;
        End
        Else If lastTradeExitProfit &lt; 0 Then Begin
            weeklyLossTrades = weeklyLossTrades + 1;
            weeklyGrossLoss = weeklyGrossLoss + lastTradeExitProfit;
            If lastTradeExitProfit &lt; weeklyLargestLoss Then
                weeklyLargestLoss = lastTradeExitProfit;
        End;
    End;
    
    { === STATS MENSUELLES === }
    If Date &gt;= lastMonthlyResetDate Then Begin
        If lastTradeExitProfit &gt; 0 Then Begin
            monthlyWinTrades = monthlyWinTrades + 1;
            monthlyGrossProfit = monthlyGrossProfit + lastTradeExitProfit;
            If lastTradeExitProfit &gt; monthlyLargestWin Then
                monthlyLargestWin = lastTradeExitProfit;
        End
        Else If lastTradeExitProfit &lt; 0 Then Begin
            monthlyLossTrades = monthlyLossTrades + 1;
            monthlyGrossLoss = monthlyGrossLoss + lastTradeExitProfit;
            If lastTradeExitProfit &lt; monthlyLargestLoss Then
                monthlyLargestLoss = lastTradeExitProfit;
        End;
    End;
End;

{ 11. RESET DES STATISTIQUES LORS DES NOUVEAUX CYCLES }

{ Reset des stats journali?res }
If Date &lt;&gt; lastDailyResetDate OR (Time = param_DailyResetHour AND Time[1] &lt;&gt; param_DailyResetHour) Then Begin
    dailyWinTrades = 0; dailyLossTrades = 0;
    dailyGrossProfit = 0; dailyGrossLoss = 0;
    dailyLargestWin = 0; dailyLargestLoss = 0;
End;

{ Reset des stats hebdomadaires }
If DayOfWeek(Date) = param_WeeklyResetDay AND DayOfWeek(Date[1]) &lt;&gt; param_WeeklyResetDay Then Begin
    weeklyWinTrades = 0; weeklyLossTrades = 0;
    weeklyGrossProfit = 0; weeklyGrossLoss = 0;
    weeklyLargestWin = 0; weeklyLargestLoss = 0;
End;

{ Reset des stats mensuelles }
If DayOfMonth(Date) = param_MonthlyResetDay AND DayOfMonth(Date[1]) &lt;&gt; param_MonthlyResetDay Then Begin
    monthlyWinTrades = 0; monthlyLossTrades = 0;
    monthlyGrossProfit = 0; monthlyGrossLoss = 0;
    monthlyLargestWin = 0; monthlyLargestLoss = 0;
End;
</pre>
        </div>
    </div>
</body>
</html>
