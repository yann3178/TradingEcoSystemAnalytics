<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATS_RP3B_v0.1 - Strategy Analysis</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        .header-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .info-box {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .info-box strong {
            color: #2c3e50;
            display: block;
            margin-bottom: 5px;
        }
        .score {
            font-size: 24px;
            font-weight: bold;
            color: #27ae60;
        }
        .score.low {
            color: #e74c3c;
        }
        .score.medium {
            color: #f39c12;
        }
        .section {
            margin: 25px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .code-block {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        .badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            background-color: #3498db;
            color: white;
            font-size: 14px;
            margin-right: 10px;
        }
        .badge.yes {
            background-color: #27ae60;
        }
        .badge.no {
            background-color: #95a5a6;
        }
        ul {
            list-style-type: none;
            padding-left: 0;
        }
        ul li {
            padding: 8px;
            margin: 5px 0;
            background-color: #e8f4f8;
            border-left: 3px solid #3498db;
            padding-left: 15px;
        }
        .quality-analysis {
            background-color: #fff9e6;
            border: 1px solid #f1c40f;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
    <style>
        /* KPI Dashboard Styles */
        .kpi-dashboard {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .kpi-dashboard h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        
        .kpi-dashboard h3 {
            color: #34495e;
            margin: 20px 0 15px 0;
            font-size: 1.1em;
        }
        
        .kpi-header-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .kpi-chip {
            background: white;
            border-radius: 20px;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .chip-label {
            color: #7f8c8d;
            font-size: 0.85em;
        }
        
        .chip-value {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .kpi-main-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .kpi-secondary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .kpi-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .kpi-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }
        
        .kpi-card.main {
            padding: 20px;
        }
        
        .kpi-card.main .kpi-value {
            font-size: 1.8em;
        }
        
        .kpi-title {
            color: #7f8c8d;
            font-size: 0.85em;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .kpi-value {
            font-size: 1.4em;
            font-weight: 700;
            color: #2c3e50;
        }
        
        .kpi-value.positive {
            color: #27ae60;
        }
        
        .kpi-value.negative {
            color: #e74c3c;
        }
        
        .kpi-value.neutral {
            color: #7f8c8d;
        }
        
        .kpi-subtitle {
            font-size: 0.8em;
            color: #95a5a6;
            margin-top: 5px;
        }
        
        /* IS/OOS Section */
        .isoos-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .isoos-info {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .isoos-badge {
            padding: 12px 20px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .isoos-badge.is {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }
        
        .isoos-badge.oos {
            background: linear-gradient(135deg, #27ae60 0%, #219a52 100%);
            color: white;
        }
        
        .badge-label {
            font-size: 0.8em;
            opacity: 0.9;
        }
        
        .badge-value {
            font-weight: 600;
        }
        
        .badge-duration {
            font-size: 0.85em;
            opacity: 0.9;
        }
        
        .isoos-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }
        
        /* Period Table */
        .period-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .period-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95em;
        }
        
        .period-table th {
            background: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 2px solid #e9ecef;
        }
        
        .period-table td {
            padding: 12px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .period-table tr:hover {
            background: #f8f9fa;
        }
        
        .period-table .positive {
            color: #27ae60;
            font-weight: 500;
        }
        
        .period-table .negative {
            color: #e74c3c;
            font-weight: 500;
        }
        
        /* Equity Curve Section */
        .equity-section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .equity-section h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            border-left: 4px solid #27ae60;
            padding-left: 15px;
        }
        
        .equity-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }
        
        .legend-item .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }
        
        .legend-item.is .legend-color {
            background: #3498db;
        }
        
        .legend-item.oos .legend-color {
            background: #27ae60;
        }
        
        .legend-item.separator {
            color: #e74c3c;
            font-weight: 500;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }
        
        .equity-source {
            margin-top: 10px;
            text-align: right;
            color: #95a5a6;
        }
        
        .no-data {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            color: #856404;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .kpi-main-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .kpi-secondary-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .chart-container {
                height: 300px;
            }
        }
    </style>
    
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Strategy List</a>
        
        <h1>üìä ATS_RP3B_v0.1</h1>
        
        <div class="header-info">
            <div class="info-box">
                <strong>Strategy Type</strong>
                <span class="badge">Error</span>
            </div>
            <div class="info-box">
                <strong>Subtype</strong>
                <span class="badge">Analysis Failed</span>
            </div>
            <div class="info-box">
                <strong>Complexity Score</strong>
                <span class="score ">N/A/10</span>
            </div>
            <div class="info-box">
                <strong>Quality Score</strong>
                <span class="score ">N/A/10</span>
            </div>
        </div>

        
            <div class="kpi-dashboard">
                <h2>üìà Performance Dashboard</h2>
                <div class="no-data">
                    <p>‚ö†Ô∏è N/A - No performance data available for this strategy in Portfolio Report.</p>
                </div>
            </div>
            

            <div class="equity-section">
                <h2>üìà Equity Curve</h2>
                <div class="no-data">
                    <p>‚ö†Ô∏è N/A - Equity curve data not available (no matching DataSource file).</p>
                </div>
            </div>
            
        <div class="section">
            <h2>üìù Summary</h2>
            <p>Analysis failed: API error: Error code: 401 - {'type': 'error', 'error': {'type': 'authentication_error', 'message': 'invalid x-api-key'}, 'request_id': 'req_011CVUr47sJg7VC6JZRsNRa3'}</p>
        </div>

        <div class="section">
            <h2>üéØ Entry Conditions</h2>
            <p>N/A</p>
        </div>

        <div class="section">
            <h2>üö™ Exit Conditions</h2>
            <p>N/A</p>
        </div>

        <div class="header-info">
            <div class="info-box">
                <strong>Stop Loss</strong>
                <p>N/A</p>
            </div>
            <div class="info-box">
                <strong>Take Profit</strong>
                <p>N/A</p>
            </div>
            <div class="info-box">
                <strong>Exit On Close</strong>
                <span class="badge no">N/A</span>
            </div>
            <div class="info-box">
                <strong>Time Exit Condition</strong>
                <span class="badge no">N/A</span>
            </div>
        </div>

        <div class="section">
            <strong>Time Exit Details:</strong>
            <p>N/A</p>
        </div>

        <div class="section">
            <h2>üîß Function Patterns Used</h2>
            <ul>
                <li>No patterns identified</li>
            </ul>
            <p><strong>Number of patterns:</strong> N/A</p>
        </div>

        <div class="quality-analysis">
            <h2>‚≠ê Quality Analysis</h2>
            <p>API error: Error code: 401 - {'type': 'error', 'error': {'type': 'authentication_error', 'message': 'invalid x-api-key'}, 'request_id': 'req_011CVUr47sJg7VC6JZRsNRa3'}</p>
        </div>

        <h2>üíª Strategy Code</h2>
        <div class="code-block">
            <pre>{ ALGORITHME ATS 
Base sur ATS V0.8 pour deriver le RP3B
}

// Version initialisee le 8 Aout 2025 : tout a faire, j&#39;ai juste nettoyer le code ATS original. Il faut creer le code pour detection RP3B (yc SAR va ou a croise M20). Cf code pinescript.

// 9/08 : premiere version ebauche marche bien. A priori on peut simplifier a mort sans necessiter le Multitimeframe ni le besoin de &quot;cluster de support&quot; par contre il faudra rendre les objectifs dynamiques car les MM bougent.

{ ALGORITHME ATS - VERSION RP3B }


{===========================================================}
{                   DECLARATIONS GLOBALES                   }
{===========================================================}

//Michael formula calculation begin
Input:SessionStartTimeA(0110), sessionEndTimeA(2200); //Set here your session time!
array:ohlcvalues[23](0), adxCalcValues[3](0);
var:IsStartOfSession(false);


IsStartOfSession=_OHLCMulti5(SessionStartTimeA,sessionEndTimeA,ohlcvalues);
//Michael formula calculation end


{Definition des constantes pour les indices des timeframes}
Vars: 
    TF_15MIN(1), TF_1HOUR(2), TF_4HOUR(3), TF_DAILY(4), TF_WEEKLY(5), TF_MONTHLY(6),
    timeframeIdx(0), indicatorIdx(0), dataStream(0), 
    currentPrice(0);

{Definition des constantes pour les indices des variables}
Vars:
    IDX_M7(1), IDX_M20(2), IDX_BBH(3), IDX_BBL(4), IDX_SAR(5),
    IDX_OGGY1(6), IDX_OGGY2(7), IDX_OGGY3(8),
    IDX_JACK1(9), IDX_JACK2(10), IDX_JACK3(11),
    IDX_CLOSEST_SUPPORT(12), IDX_CLOSEST_RESISTANCE(13);

{Tableaux pour stocker les valeurs numeriques}
Arrays:
    UTData[6,13](0), {6 timeframes x 13 variables numeriques}
    IndicatorsValueArray[6,11,2](0), {6 timeframes x 11 indicateurs x 2 (valeur, au-dessus/en-dessous)}
    IndicatorsNameArray[6,11,2](&quot;&quot;);


{Tableaux pour les variables de type string}
Arrays:
    UTBollPhase[6](&quot;P1&quot;);
    


{Tableau pour stocker les noms des timeframes}
Arrays:
    UTNames[6](&quot;&quot;);

{Tableau pour stocker les durees des P2H}
Arrays:
    UTDureeP2H[6](0),                  // Compteur de barres en P2H par timeframe
    UTDureeP2B[6](0);                  // Compteur de barres en P2H par timeframe


{Variables et tableaux pour la Grande Fenetre (GF)}
Vars:
    GF_ClosestSupport(0), 
    GF_ClosestResistance(0),
    GF_isSupportCluster(false), 
    GF_isResistanceCluster(false),
    GF_SupportName(&quot;&quot;), 
    GF_ResistanceName(&quot;&quot;),
    SupportClusterCount(0), 
    ResistanceClusterCount(0),
    clusterIdx(0);

{Tableaux pour la Grande Fenetre}
Arrays:
    GF_Supports[100](0), 
    GF_Resistances[100](0),
    GF_AllIndicatorsValue[100](0), 
    GF_AllIndicatorsName[100](&quot;&quot;);

{Variables pour les signaux de la Grande Fenetre}
Vars: 
    GF_SignauxHaussiers(&quot;&quot;), 
    GF_NbSignauxHaussiersRecents(0),
    GF_SignauxBaissiers(&quot;&quot;), 
    GF_NbSignauxBaissiersRecents(0);

{Variables pour les scenarios de trading}
Vars: 
    GF_PossibleScenarioLong(&quot;&quot;),
    GF_CodeScenarioLong(&quot;&quot;);
    
{ 2. VARIABLES DE TRACKING MULTI-HORIZONS }
Vars:
    { === TRACKING JOURNALIER === }
    dailyProfit(0), dailyTradingEnabled(true), lastDailyResetDate(0),
    dailyStartProfit(0), dailyTradeCount(0),
    
    { === TRACKING HEBDOMADAIRE === }
    weeklyProfit(0), weeklyTradingEnabled(true), lastWeeklyResetDate(0),
    weeklyStartProfit(0), weeklyTradeCount(0), currentWeek(0),
    
    { === TRACKING MENSUEL === }
    monthlyProfit(0), monthlyTradingEnabled(true), lastMonthlyResetDate(0), 
    monthlyStartProfit(0), monthlyTradeCount(0), currentMonth(0),
    
    { === VARIABLES COMMUNES === }
    globalTradingEnabled(true),        // Flag global (AND de tous les horizons)
    lastTradeExitProfit(0);
    
{===========================================================}
{        PARAMETRES DE CONFIGURATION UTILISATEUR            }
{===========================================================}

{Parametres Affichage}
Inputs:
	DisplayATSConfiguration(0),
	DisplayPerfo (1);

{Parametres de direction et strategie}
Inputs:
    LONG_RP3B_PtnNeut_Yes(55), LONG_RP3B_PtnNeut_No(56),LONG_RP3B_PtnDir_Yes(52),LONG_RP3B_PtnDir_No(53), //optimize Neutral from 1 to 55 (55=true, 56=false). Directional from -152 to 152 (152=true, 153=false)
    noTradingMonth(0), noTradingDay(6);
        
Inputs:
    param_MinDureeP2H(1),              // Dur?e minimum en P2H avant signal (en barres)
    param_MaxDureeP2H(20),             // Dur?e maximum en P2H pour ?viter signaux tardifs
    param_EnableDureeP2HFilter(true);  // Activer/d?sactiver le filtre dur?e P2H

Inputs:
    param_exit_rp3b (0);

{Parametres d&#39;analyse technique}
Inputs:
    param_ClusterPips(5),
    param_rate (0.5),
    pente_factor (1);

{Parametres de gestion du risque}
Inputs:

    param_SLLong(100), 
    param_TPLong(70), 
    param_TrailingSL (60);

{Parametres de Money Management}    
Inputs:
    { === PARAMETRES JOURNALIERS === }
    param_DailyLossLimit(-5000),        // Limite de perte journali?re
    param_DailyProfitTarget(1000),     // Objectif de profit journalier
    param_EnableDailyLossFilter(1), 
    param_EnableDailyProfitTarget(0),
    param_DailyResetHour(0000),        // Reset journalier
    
    { === PARAMETRES HEBDOMADAIRES === }
    param_WeeklyLossLimit(-12500),      // Limite de perte hebdomadaire
    param_WeeklyProfitTarget(3000),    // Objectif de profit hebdomadaire
    param_EnableWeeklyLossFilter(1),
    param_EnableWeeklyProfitTarget(0),
    param_WeeklyResetDay(1),           // 1=Dimanche, 2=Lundi, etc.
    
    { === PARAMETRES MENSUELS === }
    param_MonthlyLossLimit(-20000),     // Limite de perte mensuelle
    param_MonthlyProfitTarget(8000),   // Objectif de profit mensuel
    param_EnableMonthlyLossFilter(1),
    param_EnableMonthlyProfitTarget(0),
    param_MonthlyResetDay(1);          // Jour du mois pour reset (1er)    

{Parametres de session de trading}
Inputs:
    session_StartTime(0100), 
    session_EndTime(2000), 
    session_PauseStart1(800), 
    session_PauseEnd1(1000),
    session_PauseStart2(2300), 
    session_PauseEnd2(2300);
    
{Parametres de gestion des positions}
Inputs:
    param_MaxDaysInTrade(5), 
    param_CloseOnFriday(1), 
    param_ExitOnSessionClose(1), 
    myContract(2);

{Variables de position consolidees}
Vars:
    positionOpen(false), 
    positionType(0), 
    entryPrice(0),
    stopPrice(0), 
    targetPrice(0), 
    entryDate(0), 
    entryTime(0),
    breakEvenActive(false), 
    currentProfit(0);

{Variables de session consolid?es}
Vars:
    currentTime(0), 
    currentDate(0), 
    daysSinceEntry(0),
    inTradingHours(false), 
    inPauseTime(false), 
    isFriday(false),
    shouldExit(false), 
    canTradeLong(false);
{Variables pour calculs Bollinger factoris?es}
Vars:
    bbMiddle(0), bbUpper(0), bbLower(0), bbStdDev(0);

{===========================================================}
{                INITIALISATION DU SYST?ME                  }
{===========================================================}

Once Begin
    {Definir les noms des timeframes}
    UTNames[TF_15MIN] = &quot;15min&quot;;
    UTNames[TF_1HOUR] = &quot;60min&quot;;
    UTNames[TF_4HOUR] = &quot;4H&quot;;
    UTNames[TF_DAILY] = &quot;Daily&quot;;
    UTNames[TF_WEEKLY] = &quot;Weekly&quot;;
    UTNames[TF_MONTHLY] = &quot;Monthly&quot;;
    
    Print(&quot;---- Initialisation du systeme ----&quot;);
    Print(&quot;Date de demarrage:&quot;, Date, &quot; Heure:&quot;, Time);
End;

{ ============== GESTION DES RESETS MULTI-HORIZONS ============== }

{ === RESET JOURNALIER === }
If Date &lt;&gt; lastDailyResetDate Then Begin // OR (Time = param_DailyResetHour AND Time[1] &lt;&gt; param_DailyResetHour) Then Begin
    If dailyProfit &lt;&gt; 0 Then Begin
        Print(&quot;=== BILAN JOURNALIER ===&quot;);
        Print(&quot;Date: &quot;, lastDailyResetDate, &quot; | Profit: &quot;, dailyProfit, &quot; | Trades: &quot;, dailyTradeCount);
    End;
    
    dailyProfit = 0;
    dailyTradingEnabled = true;
    dailyTradeCount = 0;
    lastDailyResetDate = Date;
    dailyStartProfit = NetProfit;
    
    Print(&quot;Reset journalier - Date: &quot;, Date);
End;

{ === RESET HEBDOMADAIRE === }
If DayOfWeek(Date) = param_WeeklyResetDay AND DayOfWeek(Date[1]) &lt;&gt; param_WeeklyResetDay Then Begin
    If weeklyProfit &lt;&gt; 0 Then Begin
        Print(&quot;=== BILAN HEBDOMADAIRE ===&quot;);
        Print(&quot;Semaine termin?e | Profit: &quot;, weeklyProfit, &quot; | Trades: &quot;, weeklyTradeCount);
        //Print(&quot;Status: &quot;, IFF(weeklyTradingEnabled, &quot;ACTIF&quot;, &quot;BLOQUE&quot;));
    End;
    
    weeklyProfit = 0;
    weeklyTradingEnabled = true;
    weeklyTradeCount = 0;
    lastWeeklyResetDate = Date;
    weeklyStartProfit = NetProfit;
    currentWeek = currentWeek + 1;
    
    Print(&quot;=== NOUVELLE SEMAINE ===&quot;);
    Print(&quot;Semaine #&quot;, currentWeek, &quot; | Reset le: &quot;, Date);
End;

{ === RESET MENSUEL === }
If Month(Date) &lt;&gt; Month(Date[1]) Then Begin //DayOfMonth(Date) = param_MonthlyResetDay AND DayOfMonth(Date[1]) &lt;&gt; param_MonthlyResetDay Then Begin
    If monthlyProfit &lt;&gt; 0 Then Begin
        Print(&quot;=== BILAN MENSUEL ===&quot;);
        Print(&quot;Mois: &quot;, Month(Date[1]), &quot;/&quot;, Year(Date[1]));
        Print(&quot;Profit mensuel: &quot;, monthlyProfit, &quot; | Trades: &quot;, monthlyTradeCount);
        //Print(&quot;Status final: &quot;, IFF(monthlyTradingEnabled, &quot;ACTIF&quot;, &quot;BLOQUE&quot;));
    End;
    
    monthlyProfit = 0;
    monthlyTradingEnabled = true;
    monthlyTradeCount = 0;
    lastMonthlyResetDate = Date;
    monthlyStartProfit = NetProfit;
    currentMonth = Month(Date);
    
    Print(&quot;=== NOUVEAU MOIS ===&quot;);
    Print(&quot;Mois: &quot;, Month(Date), &quot;/&quot;, Year(Date), &quot; | Reset le: &quot;, Date);
End;


{ 4. CALCUL DES PROFITS EN TEMPS REEL }

{ ============== CALCUL DES PROFITS MULTI-HORIZONS ============== }
{ Calcul base sur NetProfit }
dailyProfit = NetProfit - dailyStartProfit;
weeklyProfit = NetProfit - weeklyStartProfit;
monthlyProfit = NetProfit - monthlyStartProfit;

{ Tracking des trades ferm?s }
If MarketPosition = 0 AND MarketPosition[1] &lt;&gt; 0 Then Begin
    lastTradeExitProfit = NetProfit - NetProfit[1];
    
    { Mise a jour des compteurs si trade ferme dans la periode courante }
    If Date = lastDailyResetDate Then
        dailyTradeCount = dailyTradeCount + 1;
    If Date &gt;= lastWeeklyResetDate Then
        weeklyTradeCount = weeklyTradeCount + 1;
    If Date &gt;= lastMonthlyResetDate Then
        monthlyTradeCount = monthlyTradeCount + 1;
        
    Print(&quot;Trade ferm? - P&amp;L: &quot;, lastTradeExitProfit);
    Print(&quot;Profits - Jour: &quot;, dailyProfit, &quot; | Semaine: &quot;, weeklyProfit, &quot; | Mois: &quot;, monthlyProfit);
End;

{ 5. VERIFICATION DES LIMITES MULTI-HORIZONS }

{ ============== VERIFICATION DES LIMITES JOURNALIERES ============== }
If param_EnableDailyLossFilter=1 AND dailyProfit &lt;= param_DailyLossLimit AND dailyTradingEnabled Then Begin
    dailyTradingEnabled = false;
    Print(&quot;*** LIMITE JOURNALIERE ATTEINTE ***&quot;);
    Print(&quot;Profit jour: &quot;, dailyProfit, &quot; | Limite: &quot;, param_DailyLossLimit);
    Print(&quot;TRADING SUSPENDU jusqu&#39;a demain&quot;);
End;

If param_EnableDailyProfitTarget=1 AND dailyProfit &gt;= param_DailyProfitTarget AND dailyTradingEnabled Then Begin
    dailyTradingEnabled = false;
    Print(&quot;*** OBJECTIF JOURNALIER ATTEINT ***&quot;);
    Print(&quot;Profit jour: &quot;, dailyProfit, &quot; | Objectif: &quot;, param_DailyProfitTarget);
    Print(&quot;TRADING SUSPENDU jusqu&#39;? demain&quot;);
End;

{ ============== VERIFICATION DES LIMITES HEBDOMADAIRES ============== }
If param_EnableWeeklyLossFilter=1 AND weeklyProfit &lt;= param_WeeklyLossLimit AND weeklyTradingEnabled Then Begin
    weeklyTradingEnabled = false;
    Print(&quot;*** LIMITE HEBDOMADAIRE ATTEINTE ***&quot;);
    Print(&quot;Profit semaine: &quot;, weeklyProfit, &quot; | Limite: &quot;, param_WeeklyLossLimit);
    Print(&quot;TRADING SUSPENDU jusqu&#39;? la semaine prochaine&quot;);
End;

If param_EnableWeeklyProfitTarget=1 AND weeklyProfit &gt;= param_WeeklyProfitTarget AND weeklyTradingEnabled Then Begin
    weeklyTradingEnabled = false;
    Print(&quot;*** OBJECTIF HEBDOMADAIRE ATTEINT ***&quot;);
    Print(&quot;Profit semaine: &quot;, weeklyProfit, &quot; | Objectif: &quot;, param_WeeklyProfitTarget);
    Print(&quot;TRADING SUSPENDU jusqu&#39;a la semaine prochaine&quot;);
End;

{ ============== VERIFICATION DES LIMITES MENSUELLES ============== }
If param_EnableMonthlyLossFilter=1 AND monthlyProfit &lt;= param_MonthlyLossLimit AND monthlyTradingEnabled Then Begin
    monthlyTradingEnabled = false;
    Print(&quot;*** LIMITE MENSUELLE ATTEINTE ***&quot;);
    Print(&quot;Profit mois: &quot;, monthlyProfit, &quot; | Limite: &quot;, param_MonthlyLossLimit);
    Print(&quot;TRADING SUSPENDU jusqu&#39;au mois prochain&quot;);
End;

If param_EnableMonthlyProfitTarget=1 AND monthlyProfit &gt;= param_MonthlyProfitTarget AND monthlyTradingEnabled Then Begin
    monthlyTradingEnabled = false;
    Print(&quot;*** OBJECTIF MENSUEL ATTEINT ***&quot;);
    Print(&quot;Profit mois: &quot;, monthlyProfit, &quot; | Objectif: &quot;, param_MonthlyProfitTarget);
    Print(&quot;TRADING SUSPENDU jusqu&#39;au mois prochain&quot;);
End;

{ 6. CALCUL DU FLAG GLOBAL DE TRADING }

{ ============== FLAG GLOBAL DE TRADING ============== }
{ Le trading n&#39;est autorise que si TOUS les horizons sont OK }
globalTradingEnabled = dailyTradingEnabled AND weeklyTradingEnabled AND monthlyTradingEnabled;

{ Fermeture forcee si l&#39;un des horizons est bloque }
If NOT globalTradingEnabled AND MarketPosition &lt;&gt; 0 Then Begin
    Print(&quot;*** FERMETURE FORCEE - LIMITE ATTEINTE ***&quot;);
    If NOT dailyTradingEnabled Then Print(&quot;Cause: Limite journali?re&quot;);
    If NOT weeklyTradingEnabled Then Print(&quot;Cause: Limite hebdomadaire&quot;);
    If NOT monthlyTradingEnabled Then Print(&quot;Cause: Limite mensuelle&quot;);
    
    If MarketPosition &gt; 0 Then
        Sell(&quot;Limit_Exit&quot;) currentcontracts contracts next bar at market
    Else
        BuyToCover(&quot;Limit_Exit&quot;) next bar at market;
End;
{===========================================================}
{              TRAITEMENT PRINCIPAL DU SYSTEME              }
{===========================================================}

{===========================================================}
{           MODULE 1: CALCUL DES CONDITIONS GLOBALES        }
{===========================================================}

{Calcul des conditions de session une seule fois}
currentTime = Time;
currentDate = Date;
isFriday = DayOfWeek(currentDate) = 5;
inTradingHours = (currentTime &gt;= session_StartTime AND currentTime &lt;= session_EndTime);
inPauseTime = (currentTime &gt;= session_PauseStart1 AND currentTime &lt;= session_PauseEnd1);
canTradeLong = inTradingHours AND NOT inPauseTime;

{Recuperer le prix actuel une seule fois}
currentPrice = Close;

{===========================================================}
{           MODULE 2: CALCUL DES INDICATEURS PAR UT         }
{===========================================================}

{BOUCLE PRINCIPALE OPTIMIS?E}
For timeframeIdx = TF_15MIN To TF_MONTHLY 
Begin
    {Variables locales factoris?es pour les calculs}
    Vars: 
        m7(0), m7_1(0), m7_2(0), m7_3(0),
        m20(0), m20_1(0), m20_2(0), m20_3(0),
        close_1(0), close_2(0), close_3(0),
        currentPhase(&quot;&quot;),
        supportCounter(0), resistanceCounter(0),
        minSupportValue(999999), minResistanceValue(999999);
    
    {Selection du bon flux de donnees selon le timeframe}
    If timeframeIdx = TF_15MIN Then dataStream = 1
    Else If timeframeIdx = TF_1HOUR Then dataStream = 2
    Else If timeframeIdx = TF_4HOUR Then dataStream = 3
    Else If timeframeIdx = TF_DAILY Then dataStream = 4
    Else If timeframeIdx = TF_WEEKLY Then dataStream = 5
    Else dataStream = 6;
    
    {CALCUL DES INDICATEURS PRINCIPAUX - FACTORIS?}
    UTData[timeframeIdx, IDX_M7] = Average(Close of data(dataStream), 7);
    UTData[timeframeIdx, IDX_M20] = Average(Close of data(dataStream), 20);
    UTData[timeframeIdx, IDX_SAR] = ATS_ParabolicSAR_TF(0.02, 0.02, 0.2) of Data(dataStream);
    
    {Calcul des Bandes de Bollinger factoris?}
    bbMiddle = UTData[timeframeIdx, IDX_M20];
    bbStdDev = StandardDev(Close of data(dataStream), 20, 1);
    UTData[timeframeIdx, IDX_BBH] = bbMiddle + 2 * bbStdDev;
    UTData[timeframeIdx, IDX_BBL] = bbMiddle - 2 * bbStdDev;
    
    {Calcul des Oggy et Jack}
    UTData[timeframeIdx, IDX_OGGY1] = Close[7] of data(dataStream);
    UTData[timeframeIdx, IDX_OGGY2] = Close[6] of data(dataStream);
    UTData[timeframeIdx, IDX_OGGY3] = Close[5] of data(dataStream);
    UTData[timeframeIdx, IDX_JACK1] = Close[20] of data(dataStream);
    UTData[timeframeIdx, IDX_JACK2] = Close[19] of data(dataStream);
    UTData[timeframeIdx, IDX_JACK3] = Close[18] of data(dataStream);
    
    {===========================================================}
    {     MODULE 2.1: DETERMINATION DES PHASES DE BOLLINGER     }
    {===========================================================}
    
    m7 = UTData[timeframeIdx, IDX_M7];
    m7_1 = Average(Close[1] of data(dataStream), 7);
    m7_2 = Average(Close[2] of data(dataStream), 7);
    
    {Calcul des phases de Bollinger simplifi?}
    bbUpper = UTData[timeframeIdx, IDX_BBH];
    bbLower = UTData[timeframeIdx, IDX_BBL];
    
    {Calcul des valeurs pr?c?dentes pour comparaison}
    bbStdDev = StandardDev(Close[1] of data(dataStream), 20, 1);
    bbMiddle = Average(Close[1] of data(dataStream), 20);
    Vars: bbUpper_1(0), bbLower_1(0);
    bbUpper_1 = bbMiddle + 2 * bbStdDev;
    bbLower_1 = bbMiddle - 2 * bbStdDev;
    
    {Logique de phases simplifi?e}
    If (bbUpper &gt; bbUpper_1 AND bbLower &lt; bbLower_1) Then 
    Begin {Expansion}
        If m7 &gt; m7_1 Then
            currentPhase = &quot;P2H&quot;
        Else 
        	If m7 &lt; m7_1 Then
            		currentPhase = &quot;P2B&quot;
        	Else
            		currentPhase = &quot;P4&quot;;
    End
    Else 
    	If (bbUpper &lt; bbUpper_1 AND bbLower &gt; bbLower_1) Then {Contraction}
       	currentPhase = &quot;P4&quot;
    	Else 
    		If (bbUpper &gt;= bbUpper_1 AND bbLower &gt;= bbLower_1) Then {Mont?e}
        		currentPhase = &quot;P3H&quot;
    		Else 
    			If (bbUpper &lt;= bbUpper_1 AND bbLower &lt;= bbLower_1) Then {Descente}
        			currentPhase = &quot;P3B&quot;
    			Else
        			currentPhase = &quot;P1&quot;;
        			
    {CORRECTIONS DES SEQUENCES PRINCIPALES DE PHASES}    					
    if currentPhase = &quot;P1&quot; and UTBollPhase[timeframeIdx][1] = &quot;P2H&quot; Then currentPhase=&quot;P2H&quot;;
    if currentPhase = &quot;P1&quot; and UTBollPhase[timeframeIdx][1] = &quot;P2B&quot; Then currentPhase=&quot;P2B&quot;;
    if currentPhase = &quot;P1&quot; and UTBollPhase[timeframeIdx][1] = &quot;P4&quot; and (bbUpper &lt; bbUpper_1 AND bbLower &gt; bbLower_1) Then currentPhase=&quot;P4&quot;;
    if currentPhase = &quot;P4&quot; and UTBollPhase[timeframeIdx][1] = &quot;P1&quot; then currentPhase=&quot;P1&quot;;
    if currentPhase = &quot;P3B&quot; and UTBollPhase[timeframeIdx][1] = &quot;P1&quot; then currentPhase=&quot;P1&quot;;
    if currentPhase = &quot;P3H&quot; and UTBollPhase[timeframeIdx][1] = &quot;P1&quot; then currentPhase=&quot;P1&quot;;

    
    
    {Mettre a jour la phase de Bollinger pour ce timeframe}
    UTBollPhase[timeframeIdx] = currentPhase;
    
    
    { ============== CALCUL DE LA DUREE EN P2H ============== }
    If UTBollPhase[timeframeIdx] = &quot;P2H&quot; Then 
    Begin
      { Si on ?tait d?j? en P2H la barre pr?c?dente, incr?menter le compteur }
    	If UTBollPhase[timeframeIdx][1] = &quot;P2H&quot; Then
      	UTDureeP2H[timeframeIdx] = UTDureeP2H[timeframeIdx] + 1
      Else
      	UTDureeP2H[timeframeIdx] = 1;  // Premi?re barre en P2H
	End
    Else Begin
	    { Si on n&#39;est plus en P2H, remettre le compteur ? z?ro }
	    UTDureeP2H[timeframeIdx] = 0;
    End;

    { ============== CALCUL DE LA DUREE EN P2B ============== }
    If UTBollPhase[timeframeIdx] = &quot;P2B&quot; Then 
    Begin
      { Si on ?tait d?j? en P2B la barre pr?c?dente, incr?menter le compteur }
    	If UTBollPhase[timeframeIdx][1] = &quot;P2B&quot; Then
      	UTDureeP2B[timeframeIdx] = UTDureeP2B[timeframeIdx] + 1
      Else
      	UTDureeP2B[timeframeIdx] = 1;  // Premi?re barre en P2B
	End
    Else Begin
	    { Si on n&#39;est plus en P2B, remettre le compteur ? z?ro }
	    UTDureeP2B[timeframeIdx] = 0;
    End;

    
    
	Vars: sar_cross_m20_up(false), sar_cross_m20_down(false);

	sar_cross_m20_up = (UTData[timeframeIdx, IDX_SAR][1] &gt; UTData[timeframeIdx, IDX_M20][1] AND 
	                    UTData[timeframeIdx, IDX_SAR] &lt; UTData[timeframeIdx, IDX_M20]);
	sar_cross_m20_down = (UTData[timeframeIdx, IDX_SAR][1] &lt; UTData[timeframeIdx, IDX_M20][1] AND 
	                      UTData[timeframeIdx, IDX_SAR] &gt; UTData[timeframeIdx, IDX_M20]);
    
    
    {===========================================================}
    {     MODULE 2.3: IDENTIFICATION DES SUPPORTS/RESISTANCES   }
    {===========================================================}
    
    {Remplir le tableau des indicateurs une seule fois}
    IndicatorsValueArray[timeframeIdx, 1, 1] = UTData[timeframeIdx, IDX_M7];
    IndicatorsNameArray[timeframeIdx, 1, 1] = &quot;M7-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 1, 2] = IFF(UTData[timeframeIdx, IDX_M7] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 2, 1] = UTData[timeframeIdx, IDX_M20];
    IndicatorsNameArray[timeframeIdx, 2, 1] = &quot;M20-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 2, 2] = IFF(UTData[timeframeIdx, IDX_M20] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 3, 1] = UTData[timeframeIdx, IDX_BBH];
    IndicatorsNameArray[timeframeIdx, 3, 1] = &quot;U-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 3, 2] = IFF(UTData[timeframeIdx, IDX_BBH] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 4, 1] = UTData[timeframeIdx, IDX_BBL];
    IndicatorsNameArray[timeframeIdx, 4, 1] = &quot;L-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 4, 2] = IFF(UTData[timeframeIdx, IDX_BBL] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 5, 1] = UTData[timeframeIdx, IDX_SAR];
    IndicatorsNameArray[timeframeIdx, 5, 1] = &quot;SAR-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 5, 2] = IFF(UTData[timeframeIdx, IDX_SAR] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 6, 1] = UTData[timeframeIdx, IDX_OGGY1];
    IndicatorsNameArray[timeframeIdx, 6, 1] = &quot;O1-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 6, 2] = IFF(UTData[timeframeIdx, IDX_OGGY1] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 7, 1] = UTData[timeframeIdx, IDX_OGGY2];
    IndicatorsNameArray[timeframeIdx, 7, 1] = &quot;O2-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 7, 2] = IFF(UTData[timeframeIdx, IDX_OGGY2] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 8, 1] = UTData[timeframeIdx, IDX_OGGY3];
    IndicatorsNameArray[timeframeIdx, 8, 1] = &quot;O3-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 8, 2] = IFF(UTData[timeframeIdx, IDX_OGGY3] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 9, 1] = UTData[timeframeIdx, IDX_JACK1];
    IndicatorsNameArray[timeframeIdx, 9, 1] = &quot;J1-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 9, 2] = IFF(UTData[timeframeIdx, IDX_JACK1] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 10, 1] = UTData[timeframeIdx, IDX_JACK2];
    IndicatorsNameArray[timeframeIdx, 10, 1] = &quot;J2-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 10, 2] = IFF(UTData[timeframeIdx, IDX_JACK2] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 11, 1] = UTData[timeframeIdx, IDX_JACK3];
    IndicatorsNameArray[timeframeIdx, 11, 1] = &quot;J3-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 11, 2] = IFF(UTData[timeframeIdx, IDX_JACK3] &gt; currentPrice, 1, -1);
    
    {Calcul du ClosestSupport et ClosestResistance avec verifications}
    Arrays: supports[15](0), resistances[15](0);
    supportCounter = 0;
    resistanceCounter = 0;

    For indicatorIdx = 1 to 11 Begin
        If indicatorIdx &lt;= 11 AND 
           IndicatorsValueArray[timeframeIdx, indicatorIdx, 2] &lt; 0 AND 
           IndicatorsValueArray[timeframeIdx, indicatorIdx, 1] &gt; 0 AND
           supportCounter &lt; 14 Then Begin
            supportCounter = supportCounter + 1;
            supports[supportCounter] = IndicatorsValueArray[timeframeIdx, indicatorIdx, 1];
        End
        Else If indicatorIdx &lt;= 11 AND
                IndicatorsValueArray[timeframeIdx, indicatorIdx, 2] &gt; 0 AND
                IndicatorsValueArray[timeframeIdx, indicatorIdx, 1] &gt; 0 AND
                resistanceCounter &lt; 14 Then Begin
            resistanceCounter = resistanceCounter + 1;
            resistances[resistanceCounter] = IndicatorsValueArray[timeframeIdx, indicatorIdx, 1];
        End;
    End;
    
    {Trouver les plus proches avec v?rifications de limites}
    If supportCounter &gt; 0 Then Begin
        minSupportValue = supports[1];
        For indicatorIdx = 2 to supportCounter Begin
            If indicatorIdx &lt;= supportCounter AND indicatorIdx &lt;= 14 Then Begin
                If supports[indicatorIdx] &gt; minSupportValue Then
                    minSupportValue = supports[indicatorIdx];
            End;
        End;
        UTData[timeframeIdx, IDX_CLOSEST_SUPPORT] = minSupportValue;
    End
    Else
        UTData[timeframeIdx, IDX_CLOSEST_SUPPORT] = 0;

    If resistanceCounter &gt; 0 Then Begin
        minResistanceValue = resistances[1];
        For indicatorIdx = 2 to resistanceCounter Begin
            If indicatorIdx &lt;= resistanceCounter AND indicatorIdx &lt;= 14 Then Begin
                If resistances[indicatorIdx] &lt; minResistanceValue Then
                    minResistanceValue = resistances[indicatorIdx];
            End;
        End;
        UTData[timeframeIdx, IDX_CLOSEST_RESISTANCE] = minResistanceValue;
    End
    Else
        UTData[timeframeIdx, IDX_CLOSEST_RESISTANCE] = 0;
End;

{===========================================================}
{           MODULE 3: GRANDE FENETRE ET AGREGATION          }
{===========================================================}

{Initialisation des variables et tableaux}
Vars: 
    supportIdx(0), resistanceIdx(0), allIndicatorsIdx(0), 
    utIdx(0), checkIdx(0), pdh(0), pdl(0), o1(0), c1(0), levelIdx (0);

{R?initialisation des tableaux}
For checkIdx = 1 to 100 Begin
    GF_Supports[checkIdx] = 0;
    GF_Resistances[checkIdx] = 0;
    GF_AllIndicatorsValue[checkIdx] = 0;
    GF_AllIndicatorsName[checkIdx] = &quot;&quot;;
End;

{Obtenir les donn?es du jour pr?c?dent}
OHLCPeriodsAgo(2,1, o1, pdh, pdl, c1);


{Remplissage des tableaux GF}
supportIdx = 0;
resistanceIdx = 0;
allIndicatorsIdx = 0;

For utIdx = TF_15MIN to TF_MONTHLY Begin
    For indicatorIdx = 1 to 11 Begin
        If IndicatorsValueArray[utIdx, indicatorIdx, 1] &gt; 0 AND allIndicatorsIdx &lt; 90 Then Begin
            allIndicatorsIdx = allIndicatorsIdx + 1;
            GF_AllIndicatorsValue[allIndicatorsIdx] = IndicatorsValueArray[utIdx, indicatorIdx, 1];
            GF_AllIndicatorsName[allIndicatorsIdx] = IndicatorsNameArray[utIdx, indicatorIdx, 1];
            
            If IndicatorsValueArray[utIdx, indicatorIdx, 2] &lt; 0 AND supportIdx &lt; 95  Then Begin
                supportIdx = supportIdx + 1;
                GF_Supports[supportIdx] = IndicatorsValueArray[utIdx, indicatorIdx, 1];
            End
            Else If IndicatorsValueArray[utIdx, indicatorIdx, 2] &gt; 0 AND resistanceIdx &lt; 95 Then Begin
                resistanceIdx = resistanceIdx + 1;
                GF_Resistances[resistanceIdx] = IndicatorsValueArray[utIdx, indicatorIdx, 1];
            End;
        End;
    End;
End;

{Ajout des niveaux suppl?mentaires avec classification automatique}
Arrays: levelValues[7](0), levelNames[7](&quot;&quot;), levelTypes[7](0);

{Initialiser les tableaux de niveaux}
levelValues[1] = pdh;    				levelNames[1] = &quot;PDH&quot;;
levelValues[2] = pdl;    	 		  	levelNames[2] = &quot;PDL&quot;; 
levelValues[3] = highW(1) ;   		 	levelNames[3] = &quot;PWH&quot;;
levelValues[4] = LowW(1)  ;				levelNames[4] = &quot;PWL&quot;;
levelValues[5] = HighM(1) ;	       		levelNames[5] = &quot;PMH&quot;;
levelValues[6] = LowM(1)  ;        		levelNames[6] = &quot;PML&quot;;
levelValues[7] = Highest(High of Data(6),50);    levelNames[7] = &quot;ATH&quot;;

{Boucle pour traiter tous les niveaux}
For levelIdx = 1 to 7 Begin
    If allIndicatorsIdx &lt; 95 AND levelValues[levelIdx] &gt; 0 Then Begin
        {Ajouter au tableau global}
        allIndicatorsIdx = allIndicatorsIdx + 1;
        GF_AllIndicatorsValue[allIndicatorsIdx] = levelValues[levelIdx];
        GF_AllIndicatorsName[allIndicatorsIdx] = levelNames[levelIdx];
        
        {Classification automatique}
        If levelValues[levelIdx] &gt; currentPrice Then Begin
            {R?sistance}
            If resistanceIdx &lt; 95 Then Begin
                resistanceIdx = resistanceIdx + 1;
                GF_Resistances[resistanceIdx] = levelValues[levelIdx];
            End;
        End
        Else If levelValues[levelIdx] &lt; currentPrice Then Begin
            {Support}
            If supportIdx &lt; 95 Then Begin
                supportIdx = supportIdx + 1;
                GF_Supports[supportIdx] = levelValues[levelIdx];
            End;
        End;
    End;
End;


{Tri des tableaux avec v?rification de limites}
If supportIdx &gt; 1 Then
    Array_sort(GF_Supports, 1, supportIdx, false);
If resistanceIdx &gt; 1 Then
    Array_sort(GF_Resistances, 1, resistanceIdx, true);

{Calcul des plus proches globaux}
If supportIdx &gt; 0 Then
    GF_ClosestSupport = GF_Supports[1]
Else
    GF_ClosestSupport = 0;
    
If resistanceIdx &gt; 0 Then
    GF_ClosestResistance = GF_Resistances[1]
Else
    GF_ClosestResistance = 0;

{Detection des clusters avec v?rifications de limites}
SupportClusterCount = 0;
ResistanceClusterCount = 0;

If supportIdx &gt; 1 AND GF_ClosestSupport &gt; 0 Then Begin
    For checkIdx = 1 to supportIdx Begin
        If checkIdx &lt;= supportIdx AND checkIdx &lt;= 100 Then Begin
            If absvalue(GF_ClosestSupport - GF_Supports[checkIdx]) &lt;= param_ClusterPips Then
                SupportClusterCount = SupportClusterCount + 1;
        End;
    End;
End;

If resistanceIdx &gt; 1 AND GF_ClosestResistance &gt; 0 Then Begin
    For checkIdx = 1 to resistanceIdx Begin
        If checkIdx &lt;= resistanceIdx AND checkIdx &lt;= 100 Then Begin
            If absvalue(GF_Resistances[checkIdx] - GF_ClosestResistance) &lt;= param_ClusterPips Then
                ResistanceClusterCount = ResistanceClusterCount + 1;
        End;
    End;
End;

GF_isSupportCluster = (SupportClusterCount &gt; 3);
GF_isResistanceCluster = (ResistanceClusterCount &gt; 3);



{===========================================================}
{          MODULE 4: DETECTION DES SCENARIOS TRADING        }
{===========================================================}


// On determine si SAR a croise M20
vars: sar_a_croise(false), rp3b_signal (false);

Vars: 
    LowestSinceCondition(999999),
    ConditionMet(false);
    
rp3b_signal=false;

// R?initialise quand la condition devient vraie
if UTBollPhase[1]=&quot;P2B&quot; and UTBollPhase[1][1]&lt;&gt;&quot;P2B&quot; then begin
    LowestSinceCondition = Close;
    ConditionMet = true;
end
// Met ? jour le minimum tant que la condition reste vraie ou apr?s qu&#39;elle ait ?t? vraie
else if ConditionMet then begin
    if UTBollPhase[1]&lt;&gt;&quot;P2B&quot; then
        LowestSinceCondition = MinList(LowestSinceCondition, currentPrice)
    else
        LowestSinceCondition = MinList(LowestSinceCondition, currentPrice);
end;


Vars: sar_cross_m20_up2(false), sar_cross_m20_down2(false), pente_projetee_M20 (0), pente_projetee_SAR (0), sar_va_croiser_M20(false), SAR_projete_1bar (0), SAR_projete_2bar (0),SAR_projete_3bar (0), M20_projete_1bar (0), M20_projete_2bar (0), M20_projete_3bar (0);

sar_cross_m20_up2 = (UTData[1, IDX_SAR][1] &gt; UTData[1, IDX_M20][1] AND 
                    UTData[1, IDX_SAR] &lt; UTData[1, IDX_M20]);
sar_cross_m20_down2 = (UTData[1, IDX_SAR][1] &lt; UTData[1, IDX_M20][1] AND 
                      UTData[1, IDX_SAR] &gt; UTData[1, IDX_M20]);
                      
//pente_projetee_SAR =  IFF(UTData[1,IDX_SAR][1]&gt;0, 1-pente_factor*(UTData[1,IDX_SAR][1]-UTData[1,IDX_SAR])/UTData[1,IDX_SAR],0)[1] ;
//pente_projetee_m20 = IFF(UTData[1,IDX_M20][1]&gt;0, 1-(UTData[1,IDX_M20][1]-UTData[1,IDX_M20])/UTData[1,IDX_M20][1], 0) ;
pente_projetee_SAR = IFF(UTData[1,IDX_SAR][1]&gt;0, pente_factor*UTData[1,IDX_SAR][0] / UTData[1,IDX_SAR][1], 0) ;
pente_projetee_m20 = IFF(UTData[1,IDX_M20][1]&gt;0, UTData[1,IDX_M20][0] / UTData[1,IDX_M20][1], 0) ;


SAR_projete_1bar = UTData[1,IDX_SAR] * pente_projetee_SAR;
SAR_projete_2bar = UTData[1,IDX_SAR] * square(pente_projetee_SAR);
SAR_projete_3bar = UTData[1,IDX_SAR] * square(pente_projetee_SAR)*pente_projetee_SAR;
M20_projete_1bar = UTData[1,IDX_M20] * pente_projetee_SAR;
M20_projete_2bar = UTData[1,IDX_M20] * square(pente_projetee_M20);
M20_projete_3bar = UTData[1,IDX_M20] * square(pente_projetee_M20)*pente_projetee_M20;


if ( ( UTBollPhase[1][0]=&quot;P2B&quot; and UTDureeP2B[1]&gt;=3 )  or (UTBollPhase[1]=&quot;P3B&quot; and UTBollPhase[1][1]=&quot;P2B&quot;) )
  and (close&lt; UTData[1, IDX_BBL] )// or (high&lt;UTData[1,IDX_M7] and high&gt;UTData[1,IDX_BBL] and close[1]&lt;UTData[1, IDX_BBL]) )
  and ( (sar_cross_m20_down2 or sar_cross_m20_down2[1] or sar_cross_m20_down2[2] ) 
  or   ( SAR_projete_1bar&lt; M20_projete_1bar and UTData[1,IDX_SAR]&gt;UTData[1, IDX_M20])
  or   ( SAR_projete_2bar&lt; M20_projete_2bar and SAR_projete_1bar&gt; M20_projete_1bar  ) )
// or   ( SAR_projete_3bar&lt; M20_projete_3bar and SAR_projete_2bar&gt; M20_projete_2bar  ) )
//  and // and ( UTBollPhase[1][3]=&quot;P2B&quot;)  // 
  and close&lt; UTData[1, IDX_BBL] 
  // Condition de cluster n&#39;apporte rien sur la perfo de l&#39;algo apparamment sur FDXM 15&#39; : and GF_isSupportCluster 
  and low&gt;= LowestSinceCondition
  and GF_isSupportCluster
  // Fait passe le WinRate a 100% avec avg trade de 145Eur sur FDXM mais trades rares: and close &gt; open
  // Fait passe le WinRate a 100% avec avg trade superieur a 100Eur sur FDXM  mais trades rares: and (close-low)&gt;(high-close)*param_rate 
  then
	rp3b_signal = true
  else rp3b_signal = false;




Vars:
	current_objective (0), objective_1 (0), objective_2(0), current_SL(0), buy_condition (false);

// objective_1=  maxlist(GF_ClosestResistance, UTData[1, IDX_M7]);
objective_1 = UTData[1, IDX_M7];

{If arraysize(GF_Resistances)&gt;1 Then
	objective_2= maxlist(GF_Resistances[2], minlist(UTData[1, IDX_SAR], UTData[1, IDX_M20]))
Else
	objective_2=0;}
	
objective_2= minlist(UTData[1, IDX_SAR], UTData[1, IDX_M20]);
	

//if Close-GF_ClosestSupport-param_ClusterPips &gt;0 Then
// Ajouter la condition suivante: eviter Avril et surtout Aout : (MonthFromDateTime(DateTime) &lt;&gt;8 or MonthFromDateTime(DateTime) &lt;&gt;4)  and 
buy_condition =  rp3b_signal;
//Month(Date)&lt;&gt;noTradingMonth and dayofweek(Date)&lt;&gt;noTradingDay and rp3b_signal and globalTradingEnabled;


	 		


{===========================================================}
{          MODULE 6: GESTION DES ENTREES ET SORTIES         }
{===========================================================}
Vars:
	TradingWindow (false), WeekClosure (false), DayClosure (false), exit_EndSession_condition(false), exit_uc1 (false), current_trade_scenario (&quot;&quot;);
	



WeekClosure= param_CloseOnFriday=1 and dayofweekfromdatetime(currentdate)=5 ;
DayClosure= (param_ExitOnSessionClose=1) ;



exit_EndSession_condition= WeekClosure or DayClosure ;

	
TradingWindow= tw(session_StartTime, session_EndTime) ;
 {
	or (Time&lt;session_PauseStart2 or Time&gt;session_PauseEnd2)
	or (Time&lt;session_PauseStart3 or Time&gt;session_PauseEnd3)
	);
}

if marketposition=0 and buy_condition and TradingWindow //and UTBollPhase[1]=&quot;P2B&quot;
  and (Time&lt;session_PauseStart1 or Time&gt;session_PauseEnd1) 
  and (Time&lt;session_PauseStart2 or Time&gt;session_PauseEnd2)  Then // and TradingWindow and dayofweek(date) &lt;&gt; 5 Then
	Begin
		buy (UTBollPhase[1]) 3 Contracts next bar at market;
		current_objective= objective_1;
		current_trade_scenario=GF_CodeScenarioLong;
	End;
 

setstoploss_pt(param_SLLong);//-param_ClusterPips);
//setprofittarget_pt (200);


// Gestion des TP Partiels et SL:

// Si on est en position avec 2 contrats alors on met le TP1  Objectif 1 et on monte le SL a BE
if MarketPosition = 1 and currentcontracts=3 and globalTradingEnabled then
	Begin
	    Sell(&quot;TP1_30pct&quot;) 1 contracts next bar at current_objective limit;
	    //setstoploss_pt(param_SLLong);
	End;
if MarketPosition = 1 and currentcontracts=2 and globalTradingEnabled then
	Begin
	    Sell(&quot;TP1_50pct&quot;) 1 contracts next bar at objective_2 limit;
	    setstoploss_pt(20);
	End;

if MarketPosition = 1 and currentcontracts=1 and globalTradingEnabled then
	Begin
	    settrailingstop_pt(param_TrailingSL) ; //Sell(&quot;TP1_50pct&quot;) 1 contracts next bar at current_objective limit;
	    //setstoploss_pt(param_SLLong);
	End;

// On change l&#39;objectif du trade si on est en position apres une prise de profit partielle d&#39;un contrat. 
// On affecte alors le nouvel objectif calcule (objective_1)
{if marketposition = 1 and currentContracts=1 and currentContracts[1]=2  and globalTradingEnabled then
	current_objective=objective_1;

// Si on est en position avec un seul contrat, c&#39;est qu&#39;on vise le TP2 
if MarketPosition = 1 and currentcontracts=1  and globalTradingEnabled then
	Begin
	   //current_objective=100;
	   settrailingstop_pt(param_TrailingSL);
	   //Sell(&quot;TP2_50pct&quot;) 1 contracts next bar at current_objective limit;
	   //setstoploss_pt(absvalue(close-entryprice));
	   
	End;}

//set ppfloor and ppratio to protect profit
{Inputs:
    ppfloor(6000),    // Seuil de profit minimum avant d&#39;activer la sortie
    ppratio(0.80);    // Ratio de profit ? conserver (ex: 60%)

if MaxPositionProfit &gt;= ppfloor  and globalTradingEnabled then
begin
    // Si le profit latent est retomb? sous 60% du profit maximum atteint, on sort
    if (OpenPositionProfit / MaxPositionProfit) &lt; ppratio then
    begin
        Sell next bar at market;
        BuyToCover next bar at market;
    end;
end;


// Exit conditions
if marketposition=1 and exit_EndSession_condition and globalTradingEnabled  Then
	Begin
	setexitonclose;
	exit_EndSession_condition=false;
	End;
  
if marketposition=1 and exit_uc1 and current_trade_scenario=&quot;UC1&quot;  and globalTradingEnabled Then Begin
	Sell (&quot;Exit condition&quot;) currentcontracts contracts next bar at market;
	current_trade_scenario=&quot;&quot;;
End;
// setprofittarget_pt (objective_1);

}


{===========================================================}
{          MODULE 5: DISPLAY CONFIGURATION COMPL?TE        }
{===========================================================}

Vars:
    text_id(0), text_id1(0), text_id2(0), text_id3(0), 
    line_to_display(&quot;&quot;), supports_to_display(&quot;&quot;), resistances_to_display(&quot;&quot;),
    GF_isSupportCluster_String(&quot;&quot;), GF_isResistanceCluster_String(&quot;&quot;),
    srName(&quot;&quot;), idx_findSRName(0);


If LastBarOnChart and DisplayATSConfiguration=1 Then Begin
    {Pr?paration des cha?nes pour les supports}
    srName = &quot;&quot;;
    supports_to_display = &quot;&quot;;
    
    For timeframeIdx = 1 to supportIdx Begin
        If GF_Supports[timeframeIdx] &lt;&gt; 0 AND timeframeIdx &lt;= supportIdx Then Begin
            idx_findSRName = array_indexof(GF_AllIndicatorsValue, GF_Supports[timeframeIdx]);
            If idx_findSRName &gt; 0 AND idx_findSRName &lt;= allIndicatorsIdx Then Begin
                srName = GF_AllIndicatorsName[idx_findSRName];
                supports_to_display = supports_to_display + srName + &quot; : &quot; + NumToStr(GF_Supports[timeframeIdx],0) + NewLine;
            End;
        End;
    End;
    
    {Pr?paration des cha?nes pour les r?sistances}
    srName = &quot;&quot;;
    resistances_to_display = &quot;&quot;;
    
    For timeframeIdx = 1 to resistanceIdx Begin
        If GF_Resistances[timeframeIdx] &lt;&gt; 0 AND timeframeIdx &lt;= resistanceIdx Then Begin
            idx_findSRName = array_indexof(GF_AllIndicatorsValue, GF_Resistances[timeframeIdx]);
            If idx_findSRName &gt; 0 AND idx_findSRName &lt;= allIndicatorsIdx Then Begin
                srName = GF_AllIndicatorsName[idx_findSRName];
                resistances_to_display = resistances_to_display + srName + &quot; : &quot; + NumToStr(GF_Resistances[timeframeIdx],0) + NewLine;
            End;
        End;
    End;

    {Pr?paration des cha?nes de cluster}
    If GF_isSupportCluster Then
        GF_isSupportCluster_String = &quot;YES&quot;
    Else 
        GF_isSupportCluster_String = &quot;NO&quot;;

    If GF_isResistanceCluster Then
        GF_isResistanceCluster_String = &quot;YES&quot;
    Else 
        GF_isResistanceCluster_String = &quot;NO&quot;;
        
    {Suppression de l&#39;ancien tableau}
    If text_id &gt;= 0 Then
        text_delete(text_id);

    {Tableau de configuration complet - RESTAUR?}
    line_to_display = &quot;&quot;;
    
    line_to_display = line_to_display + &quot;|            |     GF          |      UT1      |      UT2      |      UT3      |      UT4      |      UT5      |      UT6      |&quot; + NewLine;
    line_to_display = line_to_display + &quot;| M7         |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_M7],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_M7],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_M7],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_M7],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_M7],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_M7],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| M20        |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_M20],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_M20],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_M20],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_M20],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_M20],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_M20],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| BBH        |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_BBH],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_BBH],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_BBH],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_BBH],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_BBH],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_BBH],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| BBL        |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_BBL],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_BBL],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_BBL],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_BBL],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_BBL],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_BBL],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| SAR        |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_SAR],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_SAR],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_SAR],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_SAR],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_SAR],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_SAR],0) + &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| OGY1       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_OGGY1],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_OGGY1],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_OGGY1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_OGGY1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_OGGY1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_OGGY1],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| OGY2       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_OGGY2],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_OGGY2],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_OGGY2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_OGGY2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_OGGY2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_OGGY2],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| OGY3       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_OGGY3],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_OGGY3],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_OGGY3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_OGGY3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_OGGY3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_OGGY3],0) + &quot;   |     &quot; + NewLine;
      
    line_to_display = line_to_display + &quot;| JAK1       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_JACK1],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_JACK1],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_JACK1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_JACK1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_JACK1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_JACK1],0) + &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| JAK2       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_JACK2],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_JACK2],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_JACK2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_JACK2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_JACK2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_JACK2],0) + &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| JAK3       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_JACK3],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_JACK3],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_JACK3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_JACK3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_JACK3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_JACK3],0) + &quot;   |     &quot; + NewLine;
      
    line_to_display = line_to_display + &quot;| Phase      |     N/A         |     &quot; + UTBollPhase[TF_15MIN] + &quot;      |     &quot; + UTBollPhase[TF_1HOUR] + &quot;     |     &quot;
      + UTBollPhase[TF_4HOUR] + &quot;     |     &quot; + UTBollPhase[TF_DAILY] + &quot;     |     &quot; + UTBollPhase[TF_WEEKLY] + &quot;     |     &quot; + UTBollPhase[TF_MONTHLY] + &quot;     |     &quot; + NewLine;
      
    line_to_display = line_to_display + &quot;| Sup.       |    &quot; + NumToStr(GF_ClosestSupport,0) + &quot;     |     &quot; + NumToStr(UTData[TF_15MIN, IDX_CLOSEST_SUPPORT],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_CLOSEST_SUPPORT],0)+ &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Clust      |    &quot; + GF_isSupportCluster_String + &quot;     |     N/A    |     N/A   |     &quot;
      + &quot;N/A   |     N/A   |     N/A   |     N/A   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Res.       |    &quot; + NumToStr(GF_ClosestResistance,0) + &quot;     |     &quot; + NumToStr(UTData[TF_15MIN, IDX_CLOSEST_RESISTANCE],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_CLOSEST_RESISTANCE],0)+ &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Clust      |    &quot; + GF_isResistanceCluster_String + &quot;     |     N/A    |     N/A   |     &quot;
      + &quot;N/A   |     N/A   |     N/A   |     N/A   |     &quot; + NewLine;


    line_to_display = line_to_display + NewLine + &quot;SCENARIOS:&quot; + NewLine;
    line_to_display = line_to_display + &quot;Long: &quot; + GF_CodeScenarioLong + &quot; - &quot; + GF_PossibleScenarioLong + NewLine;

    text_id = text_new(date+1, time, high, line_to_display);

    {Affichage tableau des Supports et r?sistances - RESTAUR?}
    If text_id2 &gt; 0 Then
        text_delete(text_id2);

    If text_id3 &gt; 0 Then
        text_delete(text_id3);
        
    text_id2 = text_new(date, time, low, &quot;Resistances :&quot; + NewLine + resistances_to_display);
    text_id3 = text_new(date, time, currentPrice, &quot;Supports :&quot; + NewLine + supports_to_display);
End;

{ ============== TABLEAU DE BORD MULTI-HORIZONS ============== }
If LastBarOnChart AND DisplayPerfo = 1 Then Begin
    Vars: 
        multiHorizonDisplay(&quot;&quot;), 
        globalStatusColor(White),
        dailyStatusText(&quot;&quot;), weeklyStatusText(&quot;&quot;), monthlyStatusText(&quot;&quot;);
    
    { Pr?paration des textes de status }
    If dailyTradingEnabled Then 
        dailyStatusText = &quot;ACTIF&quot;
    Else 
        dailyStatusText = &quot;BLOQUE&quot;;
        
    If weeklyTradingEnabled Then 
        weeklyStatusText = &quot;ACTIF&quot;
    Else 
        weeklyStatusText = &quot;BLOQUE&quot;;
        
    If monthlyTradingEnabled Then 
        monthlyStatusText = &quot;ACTIF&quot;
    Else 
        monthlyStatusText = &quot;BLOQUE&quot;;
    
    { Construction du tableau }
    multiHorizonDisplay = &quot;=== PROFIT MULTI-HORIZONS ===&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Date: &quot; + NumToStr(Date, 0) + &quot; | Heure: &quot; + NumToStr(Time, 0) + NewLine ;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Total Net Profit: &quot; + NumToStr(NetProfit, 0)  + NewLine + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Contract Expiration Date: &quot; + datetostring(ExpirationDateFromVendor)  + NewLine + NewLine;

    
    { SECTION JOURNALIERE }
    multiHorizonDisplay = multiHorizonDisplay + &quot;--- JOURNALIER ---&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Profit: &quot; + NumToStr(dailyProfit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Limite: &quot; + NumToStr(param_DailyLossLimit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Trades: &quot; + NumToStr(dailyTradeCount, 0) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Status: &quot; + dailyStatusText + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Distance: &quot; + NumToStr(dailyProfit - param_DailyLossLimit, 2) + NewLine + NewLine;
    
    { SECTION HEBDOMADAIRE }
    multiHorizonDisplay = multiHorizonDisplay + &quot;--- HEBDOMADAIRE ---&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Profit: &quot; + NumToStr(weeklyProfit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Limite: &quot; + NumToStr(param_WeeklyLossLimit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Trades: &quot; + NumToStr(weeklyTradeCount, 0) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Status: &quot; + weeklyStatusText + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Distance: &quot; + NumToStr(weeklyProfit - param_WeeklyLossLimit, 2) + NewLine + NewLine;
    
    { SECTION MENSUELLE }
    multiHorizonDisplay = multiHorizonDisplay + &quot;--- MENSUEL ---&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Profit: &quot; + NumToStr(monthlyProfit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Limite: &quot; + NumToStr(param_MonthlyLossLimit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Trades: &quot; + NumToStr(monthlyTradeCount, 0) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Status: &quot; + monthlyStatusText + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Distance: &quot; + NumToStr(monthlyProfit - param_MonthlyLossLimit, 2) + NewLine + NewLine;
    
    { STATUS GLOBAL }
    multiHorizonDisplay = multiHorizonDisplay + &quot;=== STATUS GLOBAL ===&quot; + NewLine;
    If globalTradingEnabled Then Begin
        multiHorizonDisplay = multiHorizonDisplay + &quot;TRADING: AUTORISE&quot; + NewLine;
        globalStatusColor = Green;
    End
    Else Begin
        multiHorizonDisplay = multiHorizonDisplay + &quot;TRADING: SUSPENDU&quot; + NewLine;
        globalStatusColor = Red;
    End;
    
    { Affichage }
    Vars: multiHorizonTextId(0);
    If multiHorizonTextId &gt; 0 Then
        text_delete(multiHorizonTextId);
        
    multiHorizonTextId = text_new(date, time + 200, high + 100, multiHorizonDisplay);
    text_setcolor(multiHorizonTextId, globalStatusColor);
End;

{ 9. FONCTION DE DEBUG DETAILLEE }

{ ============== DEBUG MULTI-HORIZONS ============== }
If Mod(BarNumber, 200) = 0 Then Begin  // Debug toutes les 200 barres
    Print(&quot;=== DEBUG MULTI-HORIZONS ===&quot;);
    Print(&quot;Barre: &quot;, BarNumber, &quot; | Date: &quot;, Date, &quot; | Time: &quot;, Time);
    Print(&quot;NetProfit total: &quot;, NetProfit);
    Print(&quot;Starts - Jour: &quot;, dailyStartProfit, &quot; | Semaine: &quot;, weeklyStartProfit, &quot; | Mois: &quot;, monthlyStartProfit);
    Print(&quot;Profits - Jour: &quot;, dailyProfit, &quot; | Semaine: &quot;, weeklyProfit, &quot; | Mois: &quot;, monthlyProfit);
    Print(&quot;Status - Jour: &quot;, dailyTradingEnabled, &quot; | Semaine: &quot;, weeklyTradingEnabled, &quot; | Mois: &quot;, monthlyTradingEnabled);
    Print(&quot;GLOBAL: &quot;, globalTradingEnabled);
End;

{ 10. STATISTIQUES AVANCEES PAR HORIZON }

{ Variables pour statistiques d?taill?es }
Vars:
    { === STATISTIQUES JOURNALIERES === }
    dailyWinTrades(0), dailyLossTrades(0),
    dailyGrossProfit(0), dailyGrossLoss(0),
    dailyLargestWin(0), dailyLargestLoss(0),
    
    { === STATISTIQUES HEBDOMADAIRES === }
    weeklyWinTrades(0), weeklyLossTrades(0),
    weeklyGrossProfit(0), weeklyGrossLoss(0),
    weeklyLargestWin(0), weeklyLargestLoss(0),
    
    { === STATISTIQUES MENSUELLES === }
    monthlyWinTrades(0), monthlyLossTrades(0),
    monthlyGrossProfit(0), monthlyGrossLoss(0),
    monthlyLargestWin(0), monthlyLargestLoss(0);

{ Mise ? jour des statistiques lors des sorties }
If MarketPosition = 0 AND MarketPosition[1] &lt;&gt; 0 Then Begin
    lastTradeExitProfit = NetProfit - NetProfit[1];
    
    { === STATS JOURNALIERES === }
    If Date = lastDailyResetDate Then Begin
        If lastTradeExitProfit &gt; 0 Then Begin
            dailyWinTrades = dailyWinTrades + 1;
            dailyGrossProfit = dailyGrossProfit + lastTradeExitProfit;
            If lastTradeExitProfit &gt; dailyLargestWin Then
                dailyLargestWin = lastTradeExitProfit;
        End
        Else If lastTradeExitProfit &lt; 0 Then Begin
            dailyLossTrades = dailyLossTrades + 1;
            dailyGrossLoss = dailyGrossLoss + lastTradeExitProfit;
            If lastTradeExitProfit &lt; dailyLargestLoss Then
                dailyLargestLoss = lastTradeExitProfit;
        End;
    End;
    
    { === STATS HEBDOMADAIRES === }
    If Date &gt;= lastWeeklyResetDate Then Begin
        If lastTradeExitProfit &gt; 0 Then Begin
            weeklyWinTrades = weeklyWinTrades + 1;
            weeklyGrossProfit = weeklyGrossProfit + lastTradeExitProfit;
            If lastTradeExitProfit &gt; weeklyLargestWin Then
                weeklyLargestWin = lastTradeExitProfit;
        End
        Else If lastTradeExitProfit &lt; 0 Then Begin
            weeklyLossTrades = weeklyLossTrades + 1;
            weeklyGrossLoss = weeklyGrossLoss + lastTradeExitProfit;
            If lastTradeExitProfit &lt; weeklyLargestLoss Then
                weeklyLargestLoss = lastTradeExitProfit;
        End;
    End;
    
    { === STATS MENSUELLES === }
    If Date &gt;= lastMonthlyResetDate Then Begin
        If lastTradeExitProfit &gt; 0 Then Begin
            monthlyWinTrades = monthlyWinTrades + 1;
            monthlyGrossProfit = monthlyGrossProfit + lastTradeExitProfit;
            If lastTradeExitProfit &gt; monthlyLargestWin Then
                monthlyLargestWin = lastTradeExitProfit;
        End
        Else If lastTradeExitProfit &lt; 0 Then Begin
            monthlyLossTrades = monthlyLossTrades + 1;
            monthlyGrossLoss = monthlyGrossLoss + lastTradeExitProfit;
            If lastTradeExitProfit &lt; monthlyLargestLoss Then
                monthlyLargestLoss = lastTradeExitProfit;
        End;
    End;
End;

{ 11. RESET DES STATISTIQUES LORS DES NOUVEAUX CYCLES }

{ Reset des stats journali?res }
If Date &lt;&gt; lastDailyResetDate OR (Time = param_DailyResetHour AND Time[1] &lt;&gt; param_DailyResetHour) Then Begin
    dailyWinTrades = 0; dailyLossTrades = 0;
    dailyGrossProfit = 0; dailyGrossLoss = 0;
    dailyLargestWin = 0; dailyLargestLoss = 0;
End;

{ Reset des stats hebdomadaires }
If DayOfWeek(Date) = param_WeeklyResetDay AND DayOfWeek(Date[1]) &lt;&gt; param_WeeklyResetDay Then Begin
    weeklyWinTrades = 0; weeklyLossTrades = 0;
    weeklyGrossProfit = 0; weeklyGrossLoss = 0;
    weeklyLargestWin = 0; weeklyLargestLoss = 0;
End;

{ Reset des stats mensuelles }
If DayOfMonth(Date) = param_MonthlyResetDay AND DayOfMonth(Date[1]) &lt;&gt; param_MonthlyResetDay Then Begin
    monthlyWinTrades = 0; monthlyLossTrades = 0;
    monthlyGrossProfit = 0; monthlyGrossLoss = 0;
    monthlyLargestWin = 0; monthlyLargestLoss = 0;
End;
</pre>
        </div>
    </div>
</body>
</html>
