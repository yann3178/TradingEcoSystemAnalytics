<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YANN_RENKO_Strategy_v2.0 - Strategy Analysis</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        .header-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .info-box {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .info-box strong {
            color: #2c3e50;
            display: block;
            margin-bottom: 5px;
        }
        .score {
            font-size: 24px;
            font-weight: bold;
            color: #27ae60;
        }
        .score.low {
            color: #e74c3c;
        }
        .score.medium {
            color: #f39c12;
        }
        .section {
            margin: 25px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .code-block {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        .badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            background-color: #3498db;
            color: white;
            font-size: 14px;
            margin-right: 10px;
        }
        .badge.yes {
            background-color: #27ae60;
        }
        .badge.no {
            background-color: #95a5a6;
        }
        ul {
            list-style-type: none;
            padding-left: 0;
        }
        ul li {
            padding: 8px;
            margin: 5px 0;
            background-color: #e8f4f8;
            border-left: 3px solid #3498db;
            padding-left: 15px;
        }
        .quality-analysis {
            background-color: #fff9e6;
            border: 1px solid #f1c40f;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
    </style>
    <style>
        /* KPI Dashboard Styles */
        .kpi-dashboard {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .kpi-dashboard h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        
        .kpi-dashboard h3 {
            color: #34495e;
            margin: 20px 0 15px 0;
            font-size: 1.1em;
        }
        
        .kpi-header-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .kpi-chip {
            background: white;
            border-radius: 20px;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .chip-label {
            color: #7f8c8d;
            font-size: 0.85em;
        }
        
        .chip-value {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .kpi-main-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .kpi-secondary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .kpi-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .kpi-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }
        
        .kpi-card.main {
            padding: 20px;
        }
        
        .kpi-card.main .kpi-value {
            font-size: 1.8em;
        }
        
        .kpi-title {
            color: #7f8c8d;
            font-size: 0.85em;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .kpi-value {
            font-size: 1.4em;
            font-weight: 700;
            color: #2c3e50;
        }
        
        .kpi-value.positive {
            color: #27ae60;
        }
        
        .kpi-value.negative {
            color: #e74c3c;
        }
        
        .kpi-value.neutral {
            color: #7f8c8d;
        }
        
        .kpi-subtitle {
            font-size: 0.8em;
            color: #95a5a6;
            margin-top: 5px;
        }
        
        /* IS/OOS Section */
        .isoos-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .isoos-info {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .isoos-badge {
            padding: 12px 20px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .isoos-badge.is {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }
        
        .isoos-badge.oos {
            background: linear-gradient(135deg, #27ae60 0%, #219a52 100%);
            color: white;
        }
        
        .badge-label {
            font-size: 0.8em;
            opacity: 0.9;
        }
        
        .badge-value {
            font-weight: 600;
        }
        
        .badge-duration {
            font-size: 0.85em;
            opacity: 0.9;
        }
        
        .isoos-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }
        
        /* Period Table */
        .period-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .period-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95em;
        }
        
        .period-table th {
            background: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 2px solid #e9ecef;
        }
        
        .period-table td {
            padding: 12px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .period-table tr:hover {
            background: #f8f9fa;
        }
        
        .period-table .positive {
            color: #27ae60;
            font-weight: 500;
        }
        
        .period-table .negative {
            color: #e74c3c;
            font-weight: 500;
        }
        
        /* Equity Curve Section */
        .equity-section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .equity-section h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            border-left: 4px solid #27ae60;
            padding-left: 15px;
        }
        
        .equity-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }
        
        .legend-item .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }
        
        .legend-item.is .legend-color {
            background: #3498db;
        }
        
        .legend-item.oos .legend-color {
            background: #27ae60;
        }
        
        .legend-item.separator {
            color: #e74c3c;
            font-weight: 500;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }
        
        .equity-source {
            margin-top: 10px;
            text-align: right;
            color: #95a5a6;
        }
        
        .no-data {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            color: #856404;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .kpi-main-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .kpi-secondary-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .chart-container {
                height: 300px;
            }
        }
    </style>
    
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Strategy List</a>
        
        <h1>üìä YANN_RENKO_Strategy_v2.0</h1>
        
        <div class="header-info">
            <div class="info-box">
                <strong>Strategy Type</strong>
                <span class="badge">Error</span>
            </div>
            <div class="info-box">
                <strong>Subtype</strong>
                <span class="badge">Analysis Failed</span>
            </div>
            <div class="info-box">
                <strong>Complexity Score</strong>
                <span class="score ">N/A/10</span>
            </div>
            <div class="info-box">
                <strong>Quality Score</strong>
                <span class="score ">N/A/10</span>
            </div>
        </div>

        
            <div class="kpi-dashboard">
                <h2>üìà Performance Dashboard</h2>
                <div class="no-data">
                    <p>‚ö†Ô∏è N/A - No performance data available for this strategy in Portfolio Report.</p>
                </div>
            </div>
            

            <div class="equity-section">
                <h2>üìà Equity Curve</h2>
                <div class="no-data">
                    <p>‚ö†Ô∏è N/A - Equity curve data not available (no matching DataSource file).</p>
                </div>
            </div>
            
        <div class="section">
            <h2>üìù Summary</h2>
            <p>Analysis failed: API error: Error code: 401 - {'type': 'error', 'error': {'type': 'authentication_error', 'message': 'invalid x-api-key'}, 'request_id': 'req_011CVUr4355eX5mrYb6wPSJX'}</p>
        </div>

        <div class="section">
            <h2>üéØ Entry Conditions</h2>
            <p>N/A</p>
        </div>

        <div class="section">
            <h2>üö™ Exit Conditions</h2>
            <p>N/A</p>
        </div>

        <div class="header-info">
            <div class="info-box">
                <strong>Stop Loss</strong>
                <p>N/A</p>
            </div>
            <div class="info-box">
                <strong>Take Profit</strong>
                <p>N/A</p>
            </div>
            <div class="info-box">
                <strong>Exit On Close</strong>
                <span class="badge no">N/A</span>
            </div>
            <div class="info-box">
                <strong>Time Exit Condition</strong>
                <span class="badge no">N/A</span>
            </div>
        </div>

        <div class="section">
            <strong>Time Exit Details:</strong>
            <p>N/A</p>
        </div>

        <div class="section">
            <h2>üîß Function Patterns Used</h2>
            <ul>
                <li>No patterns identified</li>
            </ul>
            <p><strong>Number of patterns:</strong> N/A</p>
        </div>

        <div class="quality-analysis">
            <h2>‚≠ê Quality Analysis</h2>
            <p>API error: Error code: 401 - {'type': 'error', 'error': {'type': 'authentication_error', 'message': 'invalid x-api-key'}, 'request_id': 'req_011CVUr4355eX5mrYb6wPSJX'}</p>
        </div>

        <h2>üíª Strategy Code</h2>
        <div class="code-block">
            <pre>{ **********************************************************************
  RENKO TREND FOLLOWING STRATEGY v2.0.1 FINAL (CORRECTED)
  CALCULATED RENKO ON STANDARD BARS

  CRITICAL CHANGES FROM v1.0:
  - Chart Type: STANDARD TIME-BASED BARS (NOT Renko)
  - Renko bricks calculated IN MEMORY
  - Orders executed on standard bars
  - Reproducible results with controlled start price
  - Compatible with Bar Magnifier, IOG, Portfolio Trader

  ARCHITECTURE:
  - Uses external FUNCTIONS (not subroutines) with YANN_RENKO_ prefix
  - Functions: CheckLongEntry, CheckShortEntry, CalculateTrailingStop
  - All orders placed OUTSIDE of While loops (PowerLanguage requirement)

  Chart Setup:
  - Data1: 1 minute bars (or 5min, 1sec, etc.) - REQUIRED
  - Data2: Daily bars (optional) - for SMA calculation

  Platform: MultiCharts (PowerLanguage/EasyLanguage)
  Author: Generated from Specification v2.0.1
  Date: 2025-11-08

  ?? IMPORTANT:
  - This is a SIGNAL (Strategy), NOT an Indicator
  - Do NOT use Plot1, Plot2 functions (compile error)
  - Use Print() for debugging
  - Create separate Indicator for visualization
  - Requires external functions: YANN_RENKO_CheckLongEntry, etc.

********************************************************************** }

{ --------------- INPUTS --------------- }

Inputs:
    // Renko Configuration
    RENKO_START_PRICE(0),          // 0 = auto, &gt;0 = fixed start
    RENKO_ROUND_TO(0),             // Round start to multiple (0 = no rounding)
    RENKO_TYPE(&quot;PERCENTAGE&quot;),       // &quot;PERCENTAGE&quot;, &quot;FIXED_POINTS&quot;, &quot;ATR_BASED&quot;
    RENKO_SIZE(0.01),              // 0.01 = 1% for PERCENTAGE
    ATR_PERIOD(14),                // ATR period if ATR_BASED
    RENKO_ALLOW_MULTIPLE(true),    // Allow multiple bricks per bar
    RENKO_SHOW_DEBUG(false),       // Print debug to console

    // Trend Filter
    USE_TREND_FILTER(true),
    TREND_SMA_PERIOD(200),
    TREND_MARGIN(0.00),            // 0.02 = 2% margin

    // Entry Configuration
    ENTRY_CONFIRM_TYPE(&quot;FIRST_GREEN&quot;),  // &quot;FIRST_GREEN&quot; or &quot;SECOND_GREEN&quot;
    REQUIRE_NO_WICK(false),
    REQUIRE_PRIOR_RED(true),

    // Trading Direction
    ALLOW_LONG(true),
    ALLOW_SHORT(false),
    SHORT_TREND_FILTER(true),

    // Position Sizing
    POSITION_SIZE_TYPE(&quot;PERCENT_EQUITY&quot;),  // &quot;FIXED&quot; or &quot;PERCENT_EQUITY&quot;
    POSITION_SIZE_VALUE(0.90),
    INITIAL_CAPITAL(30000),

    // Stop Management
    STOP_TYPE(&quot;PREVIOUS_BRICK&quot;),
    STOP_FIXED_VALUE(0.02),        // For FIXED_PERCENT or FIXED_POINTS
    STOP_INTRADAY(true),
    STOP_TRAIL(true),
    EXIT_ON_REVERSE_BRICK(true),
    MAX_ADVERSE_BRICKS(0);         // 0 = disabled


{ --------------- VARIABLES --------------- }

Variables:
    // Renko State (intrabarpersist for IOG/Bar Magnifier compatibility)
    intrabarpersist CurrentBrick_Open(0.0),
    intrabarpersist CurrentBrick_Close(0.0),
    intrabarpersist CurrentBrick_High(0.0),
    intrabarpersist CurrentBrick_Low(0.0),
    intrabarpersist CurrentBrick_Color(0),     // 1=GREEN, -1=RED, 0=uninitialized
    intrabarpersist PreviousBrick_Close(0.0),
    intrabarpersist PreviousBrick_Color(0),
    intrabarpersist BrickSize_Current(0.0),
    intrabarpersist BrickFormationBar(0),
    intrabarpersist TotalBricksFormed(0),
    intrabarpersist ConsecutiveAdverseBricks(0),

    // Trading State
    intrabarpersist InPosition(false),
    intrabarpersist PositionDirection(0),      // 1=LONG, -1=SHORT, 0=FLAT
    intrabarpersist EntryPrice(0.0),
    intrabarpersist EntryBar(0),               // Protection against double-trade
    intrabarpersist EntryBrickClose(0.0),
    intrabarpersist StopLevel(0.0),

    // Signal Flags (set inside loops, used outside)
    intrabarpersist SignalLongEntry(false),
    intrabarpersist SignalShortEntry(false),
    intrabarpersist SignalExit(false),
    intrabarpersist ExitReason(0),             // 1=Reverse, 2=Stop, 3=MaxAdverse
    intrabarpersist PendingEntryStop(0.0),     // Stop level for pending entry

    // Indicators
    SMAValue(0.0),
    ATRValue(0.0),

    // Initialization
    StartPrice(0.0),
    IsInitialized(false),

    // Temporaries
    BricksFormedThisBar(0),
    TempPrice(0.0),
    LongSignal(false),
    ShortSignal(false),
    HasWick(false),
    GapThroughStop(false),
    ExitPrice(0.0),
    NewStopLevel(0.0);


{ --------------- INITIALIZATION --------------- }

If CurrentBar = 1 Then Begin

    // Determine start price
    If RENKO_START_PRICE &gt; 0 Then
        StartPrice = RENKO_START_PRICE
    Else
        StartPrice = Close;

    // Apply rounding if requested
    If RENKO_ROUND_TO &gt; 0 Then
        StartPrice = IntPortion(StartPrice / RENKO_ROUND_TO) * RENKO_ROUND_TO;

    // Initialize first brick
    CurrentBrick_Open = StartPrice;
    CurrentBrick_Close = StartPrice;
    CurrentBrick_High = High;
    CurrentBrick_Low = Low;
    CurrentBrick_Color = 0;
    PreviousBrick_Color = 0;
    ConsecutiveAdverseBricks = 0;

    // Calculate initial brick size
    If RENKO_TYPE = &quot;PERCENTAGE&quot; Then
        BrickSize_Current = StartPrice * RENKO_SIZE
    Else If RENKO_TYPE = &quot;FIXED_POINTS&quot; Then
        BrickSize_Current = RENKO_SIZE
    Else If RENKO_TYPE = &quot;ATR_BASED&quot; Then Begin
        ATRValue = AvgTrueRange(ATR_PERIOD);
        BrickSize_Current = ATRValue * RENKO_SIZE;
    End
    Else
        BrickSize_Current = RENKO_SIZE;

    // Safety check
    If BrickSize_Current &lt;= 0 Then
        BrickSize_Current = 1;

    IsInitialized = true;

    // Debug
    If RENKO_SHOW_DEBUG Then
        Print(&quot;=== RENKO INITIALIZED ===&quot;,
              NewLine, &quot;Date: &quot;, Date:0:0,
              NewLine, &quot;Start Price: &quot;, StartPrice:0:2,
              NewLine, &quot;Brick Size: &quot;, BrickSize_Current:0:2,
              NewLine, &quot;Type: &quot;, RENKO_TYPE);

End;


{ --------------- EARLY EXIT PROTECTION --------------- }

// Need enough bars for SMA calculation
If CurrentBar &lt; MaxList(ATR_PERIOD, TREND_SMA_PERIOD) Then Begin
    If RENKO_SHOW_DEBUG Then
        Print(&quot;Waiting for enough bars: &quot;, CurrentBar:0:0, &quot;/&quot;,
              MaxList(ATR_PERIOD, TREND_SMA_PERIOD):0:0);
End;


{ --------------- RESET SIGNAL FLAGS --------------- }

SignalLongEntry = false;
SignalShortEntry = false;
SignalExit = false;
ExitReason = 0;


{ --------------- UPDATE BRICK EXTREMES --------------- }

CurrentBrick_High = MaxList(CurrentBrick_High, High);
CurrentBrick_Low = MinList(CurrentBrick_Low, Low);


{ --------------- CALCULATE INDICATORS --------------- }

If USE_TREND_FILTER Then Begin
    // Try to use Data2 (daily) if available
    If DataCompression &gt;= 2 Then
        SMAValue = Average(Close of Data2, TREND_SMA_PERIOD)
    Else
        SMAValue = Average(Close, TREND_SMA_PERIOD);
End;

If RENKO_TYPE = &quot;ATR_BASED&quot; Then
    ATRValue = AvgTrueRange(ATR_PERIOD);


{ --------------- BRICK FORMATION LOGIC --------------- }

BricksFormedThisBar = 0;


{ ============================================ }
{ CHECK FOR UP BRICK FORMATION(S)             }
{ ============================================ }

While Close &gt;= CurrentBrick_Close + BrickSize_Current Begin

    // Save previous state
    PreviousBrick_Close = CurrentBrick_Close;
    PreviousBrick_Color = CurrentBrick_Color;

    // Create new GREEN brick
    CurrentBrick_Open = CurrentBrick_Close;
    CurrentBrick_Close = CurrentBrick_Close + BrickSize_Current;
    CurrentBrick_Color = 1;
    CurrentBrick_High = High;
    CurrentBrick_Low = Low;

    // Update counters
    TotalBricksFormed = TotalBricksFormed + 1;
    BrickFormationBar = CurrentBar;
    BricksFormedThisBar = BricksFormedThisBar + 1;

    // Update adverse brick counter
    If CurrentBrick_Color = PreviousBrick_Color Then
        ConsecutiveAdverseBricks = 0
    Else
        ConsecutiveAdverseBricks = ConsecutiveAdverseBricks + 1;

    // Recalculate brick size if PERCENTAGE
    If RENKO_TYPE = &quot;PERCENTAGE&quot; Then Begin
        BrickSize_Current = CurrentBrick_Close * RENKO_SIZE;
        If BrickSize_Current &lt;= 0 Then BrickSize_Current = 1;
    End;

    // Debug
    If RENKO_SHOW_DEBUG Then
        Print(Date:0:0, &quot; &quot;, Time:0:0, &quot; - GREEN brick #&quot;, TotalBricksFormed:0:0,
              &quot; Close: &quot;, CurrentBrick_Close:0:2,
              &quot; Size: &quot;, BrickSize_Current:0:2);

    // ==============================
    // CHECK ENTRY SIGNALS (NO ORDERS HERE!)
    // ==============================

    // Protection against double-trade on same bar
    If InPosition = false And EntryBar &lt;&gt; CurrentBar Then Begin

        // Check LONG entry using function
        LongSignal = YANN_RENKO_CheckLongEntry(
            CurrentBrick_Color,
            PreviousBrick_Color,
            ENTRY_CONFIRM_TYPE,
            REQUIRE_PRIOR_RED,
            ALLOW_LONG,
            USE_TREND_FILTER,
            Close,
            SMAValue,
            TREND_MARGIN);

        // Check SHORT entry using function
        ShortSignal = YANN_RENKO_CheckShortEntry(
            CurrentBrick_Color,
            PreviousBrick_Color,
            ENTRY_CONFIRM_TYPE,
            REQUIRE_PRIOR_RED,
            ALLOW_SHORT,
            USE_TREND_FILTER,
            Close,
            SMAValue,
            TREND_MARGIN);

        // Check LONG signal
        If LongSignal Then Begin
            // Check no wick if required
            HasWick = false;
            If REQUIRE_NO_WICK = true Then Begin
                HasWick = (CurrentBrick_Low &lt; CurrentBrick_Open);
            End;

            If HasWick = false Then Begin
                // Set signal flag (order placed outside loop)
                SignalLongEntry = true;

                // Calculate initial stop
                If STOP_TYPE = &quot;PREVIOUS_BRICK&quot; Then
                    PendingEntryStop = PreviousBrick_Close
                Else If STOP_TYPE = &quot;FIXED_PERCENT&quot; Then
                    PendingEntryStop = Close * (1 - STOP_FIXED_VALUE)
                Else If STOP_TYPE = &quot;FIXED_POINTS&quot; Then
                    PendingEntryStop = Close - STOP_FIXED_VALUE;

                If RENKO_SHOW_DEBUG Then
                    Print(&quot;&gt;&gt;&gt; LONG SIGNAL DETECTED &lt;&lt;&lt; Bar:&quot;, CurrentBar:0:0,
                          &quot; Brick:&quot;, CurrentBrick_Close:0:2, &quot; Stop:&quot;, PendingEntryStop:0:2);
            End;
        End;

        // Check SHORT signal
        If ShortSignal Then Begin
            // Check no wick if required
            HasWick = false;
            If REQUIRE_NO_WICK = true Then Begin
                HasWick = (CurrentBrick_High &gt; CurrentBrick_Open);
            End;

            If HasWick = false Then Begin
                // Set signal flag (order placed outside loop)
                SignalShortEntry = true;

                // Calculate initial stop
                If STOP_TYPE = &quot;PREVIOUS_BRICK&quot; Then
                    PendingEntryStop = PreviousBrick_Close
                Else If STOP_TYPE = &quot;FIXED_PERCENT&quot; Then
                    PendingEntryStop = Close * (1 + STOP_FIXED_VALUE)
                Else If STOP_TYPE = &quot;FIXED_POINTS&quot; Then
                    PendingEntryStop = Close + STOP_FIXED_VALUE;

                If RENKO_SHOW_DEBUG Then
                    Print(&quot;&gt;&gt;&gt; SHORT SIGNAL DETECTED &lt;&lt;&lt; Bar:&quot;, CurrentBar:0:0,
                          &quot; Brick:&quot;, CurrentBrick_Close:0:2, &quot; Stop:&quot;, PendingEntryStop:0:2);
            End;
        End;

    End;

    // ==============================
    // CHECK EXIT SIGNALS (NO ORDERS HERE!)
    // ==============================

    If InPosition Then Begin

        // Exit on reverse brick
        If EXIT_ON_REVERSE_BRICK = true Then Begin
            If PositionDirection = 1 And CurrentBrick_Color = -1 Then Begin
                SignalExit = true;
                ExitReason = 1;  // Reverse brick
                If RENKO_SHOW_DEBUG Then Print(&quot;&lt;&lt;&lt; LONG EXIT SIGNAL: Reverse Brick &gt;&gt;&gt;&quot;);
            End;

            If PositionDirection = -1 And CurrentBrick_Color = 1 Then Begin
                SignalExit = true;
                ExitReason = 1;  // Reverse brick
                If RENKO_SHOW_DEBUG Then Print(&quot;&lt;&lt;&lt; SHORT EXIT SIGNAL: Reverse Brick &gt;&gt;&gt;&quot;);
            End;
        End;
    End;

    // ==============================
    // UPDATE TRAILING STOP
    // ==============================

    If InPosition And STOP_TRAIL Then Begin
        NewStopLevel = YANN_RENKO_CalculateTrailingStop(
            PositionDirection,
            StopLevel,
            CurrentBrick_Close,
            PreviousBrick_Close,
            CurrentBrick_Color,
            STOP_TRAIL,
            STOP_TYPE);

        If NewStopLevel &lt;&gt; StopLevel Then Begin
            If RENKO_SHOW_DEBUG Then
                Print(&quot;Stop trailed: &quot;, StopLevel:0:2, &quot; -&gt; &quot;, NewStopLevel:0:2);
            StopLevel = NewStopLevel;
        End;
    End;

    // Break if not allowing multiple bricks
    If RENKO_ALLOW_MULTIPLE = false Then Break;

End;


{ ============================================ }
{ CHECK FOR DOWN BRICK FORMATION(S)           }
{ ============================================ }

While Close &lt;= CurrentBrick_Close - BrickSize_Current Begin

    // Save previous state
    PreviousBrick_Close = CurrentBrick_Close;
    PreviousBrick_Color = CurrentBrick_Color;

    // Create new RED brick
    CurrentBrick_Open = CurrentBrick_Close;
    CurrentBrick_Close = CurrentBrick_Close - BrickSize_Current;
    CurrentBrick_Color = -1;
    CurrentBrick_High = High;
    CurrentBrick_Low = Low;

    // Update counters
    TotalBricksFormed = TotalBricksFormed + 1;
    BrickFormationBar = CurrentBar;
    BricksFormedThisBar = BricksFormedThisBar + 1;

    // Update adverse brick counter
    If CurrentBrick_Color = PreviousBrick_Color Then
        ConsecutiveAdverseBricks = 0
    Else
        ConsecutiveAdverseBricks = ConsecutiveAdverseBricks + 1;

    // Recalculate brick size if PERCENTAGE
    If RENKO_TYPE = &quot;PERCENTAGE&quot; Then Begin
        BrickSize_Current = Absvalue(CurrentBrick_Close) * RENKO_SIZE;
        If BrickSize_Current &lt;= 0 Then BrickSize_Current = 1;
    End;

    // Debug
    If RENKO_SHOW_DEBUG Then
        Print(Date:0:0, &quot; &quot;, Time:0:0, &quot; - RED brick #&quot;, TotalBricksFormed:0:0,
              &quot; Close: &quot;, CurrentBrick_Close:0:2,
              &quot; Size: &quot;, BrickSize_Current:0:2);

    // ==============================
    // CHECK ENTRY SIGNALS (NO ORDERS HERE!)
    // ==============================

    // Protection against double-trade on same bar
    If InPosition = false And EntryBar &lt;&gt; CurrentBar Then Begin

        // Check LONG entry using function
        LongSignal = YANN_RENKO_CheckLongEntry(
            CurrentBrick_Color,
            PreviousBrick_Color,
            ENTRY_CONFIRM_TYPE,
            REQUIRE_PRIOR_RED,
            ALLOW_LONG,
            USE_TREND_FILTER,
            Close,
            SMAValue,
            TREND_MARGIN);

        // Check SHORT entry using function
        ShortSignal = YANN_RENKO_CheckShortEntry(
            CurrentBrick_Color,
            PreviousBrick_Color,
            ENTRY_CONFIRM_TYPE,
            REQUIRE_PRIOR_RED,
            ALLOW_SHORT,
            USE_TREND_FILTER,
            Close,
            SMAValue,
            TREND_MARGIN);

        // Check LONG signal
        If LongSignal Then Begin
            // Check no wick if required
            HasWick = false;
            If REQUIRE_NO_WICK = true Then Begin
                HasWick = (CurrentBrick_Low &lt; CurrentBrick_Open);
            End;

            If HasWick = false Then Begin
                // Set signal flag (order placed outside loop)
                SignalLongEntry = true;

                // Calculate initial stop
                If STOP_TYPE = &quot;PREVIOUS_BRICK&quot; Then
                    PendingEntryStop = PreviousBrick_Close
                Else If STOP_TYPE = &quot;FIXED_PERCENT&quot; Then
                    PendingEntryStop = Close * (1 - STOP_FIXED_VALUE)
                Else If STOP_TYPE = &quot;FIXED_POINTS&quot; Then
                    PendingEntryStop = Close - STOP_FIXED_VALUE;

                If RENKO_SHOW_DEBUG Then
                    Print(&quot;&gt;&gt;&gt; LONG SIGNAL DETECTED &lt;&lt;&lt; Bar:&quot;, CurrentBar:0:0,
                          &quot; Brick:&quot;, CurrentBrick_Close:0:2, &quot; Stop:&quot;, PendingEntryStop:0:2);
            End;
        End;

        // Check SHORT signal
        If ShortSignal Then Begin
            // Check no wick if required
            HasWick = false;
            If REQUIRE_NO_WICK = true Then Begin
                HasWick = (CurrentBrick_High &gt; CurrentBrick_Open);
            End;

            If HasWick = false Then Begin
                // Set signal flag (order placed outside loop)
                SignalShortEntry = true;

                // Calculate initial stop
                If STOP_TYPE = &quot;PREVIOUS_BRICK&quot; Then
                    PendingEntryStop = PreviousBrick_Close
                Else If STOP_TYPE = &quot;FIXED_PERCENT&quot; Then
                    PendingEntryStop = Close * (1 + STOP_FIXED_VALUE)
                Else If STOP_TYPE = &quot;FIXED_POINTS&quot; Then
                    PendingEntryStop = Close + STOP_FIXED_VALUE;

                If RENKO_SHOW_DEBUG Then
                    Print(&quot;&gt;&gt;&gt; SHORT SIGNAL DETECTED &lt;&lt;&lt; Bar:&quot;, CurrentBar:0:0,
                          &quot; Brick:&quot;, CurrentBrick_Close:0:2, &quot; Stop:&quot;, PendingEntryStop:0:2);
            End;
        End;

    End;

    // ==============================
    // CHECK EXIT SIGNALS (NO ORDERS HERE!)
    // ==============================

    If InPosition Then Begin

        // Exit on reverse brick
        If EXIT_ON_REVERSE_BRICK = true Then Begin
            If PositionDirection = 1 And CurrentBrick_Color = -1 Then Begin
                SignalExit = true;
                ExitReason = 1;  // Reverse brick
                If RENKO_SHOW_DEBUG Then Print(&quot;&lt;&lt;&lt; LONG EXIT SIGNAL: Reverse Brick &gt;&gt;&gt;&quot;);
            End;

            If PositionDirection = -1 And CurrentBrick_Color = 1 Then Begin
                SignalExit = true;
                ExitReason = 1;  // Reverse brick
                If RENKO_SHOW_DEBUG Then Print(&quot;&lt;&lt;&lt; SHORT EXIT SIGNAL: Reverse Brick &gt;&gt;&gt;&quot;);
            End;
        End;
    End;

    // ==============================
    // UPDATE TRAILING STOP
    // ==============================

    If InPosition And STOP_TRAIL Then Begin
        NewStopLevel = YANN_RENKO_CalculateTrailingStop(
            PositionDirection,
            StopLevel,
            CurrentBrick_Close,
            PreviousBrick_Close,
            CurrentBrick_Color,
            STOP_TRAIL,
            STOP_TYPE);

        If NewStopLevel &lt;&gt; StopLevel Then Begin
            If RENKO_SHOW_DEBUG Then
                Print(&quot;Stop trailed: &quot;, StopLevel:0:2, &quot; -&gt; &quot;, NewStopLevel:0:2);
            StopLevel = NewStopLevel;
        End;
    End;

    // Break if not allowing multiple bricks
    If RENKO_ALLOW_MULTIPLE = false Then Break;

End;


{ ============================================ }
{ ORDERS PLACED HERE (OUTSIDE LOOPS!)         }
{ ============================================ }

// ==============================
// ENTRY ORDERS
// ==============================

If SignalLongEntry And InPosition = false Then Begin
    // Place LONG order
    If POSITION_SIZE_TYPE = &quot;FIXED&quot; Then
        Buy (&quot;LONG&quot;) POSITION_SIZE_VALUE contracts Next Bar at Market
    Else
        Buy (&quot;LONG&quot;) Next Bar at Market;

    InPosition = true;
    PositionDirection = 1;
    EntryBar = CurrentBar;
    EntryPrice = Close;
    EntryBrickClose = CurrentBrick_Close;
    StopLevel = PendingEntryStop;
    ConsecutiveAdverseBricks = 0;

    If RENKO_SHOW_DEBUG Then
        Print(&quot;&gt;&gt;&gt; LONG ENTRY ORDER PLACED &lt;&lt;&lt; Bar:&quot;, CurrentBar:0:0);
End;

If SignalShortEntry And InPosition = false Then Begin
    // Place SHORT order
    If POSITION_SIZE_TYPE = &quot;FIXED&quot; Then
        SellShort (&quot;SHORT&quot;) POSITION_SIZE_VALUE contracts Next Bar at Market
    Else
        SellShort (&quot;SHORT&quot;) Next Bar at Market;

    InPosition = true;
    PositionDirection = -1;
    EntryBar = CurrentBar;
    EntryPrice = Close;
    EntryBrickClose = CurrentBrick_Close;
    StopLevel = PendingEntryStop;
    ConsecutiveAdverseBricks = 0;

    If RENKO_SHOW_DEBUG Then
        Print(&quot;&gt;&gt;&gt; SHORT ENTRY ORDER PLACED &lt;&lt;&lt; Bar:&quot;, CurrentBar:0:0);
End;


// ==============================
// EXIT ORDERS
// ==============================

If SignalExit Then Begin
    If PositionDirection = 1 Then Begin
        Sell (&quot;LX_Reverse&quot;) Next Bar at Market;
        If RENKO_SHOW_DEBUG Then Print(&quot;&gt;&gt;&gt; LONG EXIT ORDER PLACED &lt;&lt;&lt;&quot;);
    End;

    If PositionDirection = -1 Then Begin
        BuyToCover (&quot;SX_Reverse&quot;) Next Bar at Market;
        If RENKO_SHOW_DEBUG Then Print(&quot;&gt;&gt;&gt; SHORT EXIT ORDER PLACED &lt;&lt;&lt;&quot;);
    End;

    InPosition = false;
    PositionDirection = 0;
End;


{ ============================================ }
{ STOP LOSS MANAGEMENT (Outside Loops)        }
{ ============================================ }

If InPosition Then Begin

    // Check for gap through stop
    GapThroughStop = false;

    If PositionDirection = 1 Then Begin
        If Open &lt; StopLevel And Open &lt; Close[1] Then
            GapThroughStop = true;
    End
    Else If PositionDirection = -1 Then Begin
        If Open &gt; StopLevel And Open &gt; Close[1] Then
            GapThroughStop = true;
    End;

    // Stop hit (intraday check)
    If STOP_INTRADAY = true Then Begin

        If PositionDirection = 1 Then Begin
            If Low &lt;= StopLevel Or GapThroughStop Then Begin
                ExitPrice = IFF(GapThroughStop, Open, StopLevel);
                Sell (&quot;LX_Stop&quot;) Next Bar At ExitPrice Stop;
                InPosition = false;
                PositionDirection = 0;
                If RENKO_SHOW_DEBUG Then Print(&quot;&lt;&lt;&lt; LONG EXIT: Stop Hit &gt;&gt;&gt;&quot;);
            End;
        End;

        If PositionDirection = -1 Then Begin
            If High &gt;= StopLevel Or GapThroughStop Then Begin
                ExitPrice = IFF(GapThroughStop, Open, StopLevel);
                BuyToCover (&quot;SX_Stop&quot;) Next Bar At ExitPrice Stop;
                InPosition = false;
                PositionDirection = 0;
                If RENKO_SHOW_DEBUG Then Print(&quot;&lt;&lt;&lt; SHORT EXIT: Stop Hit &gt;&gt;&gt;&quot;);
            End;
        End;

    End

    // Stop end-of-bar
    Else Begin

        If PositionDirection = 1 And Close &lt;= StopLevel Then Begin
            Sell (&quot;LX_StopEOB&quot;) Next Bar at Market;
            InPosition = false;
            PositionDirection = 0;
            If RENKO_SHOW_DEBUG Then Print(&quot;&lt;&lt;&lt; LONG EXIT: Stop EOB &gt;&gt;&gt;&quot;);
        End;

        If PositionDirection = -1 And Close &gt;= StopLevel Then Begin
            BuyToCover (&quot;SX_StopEOB&quot;) Next Bar at Market;
            InPosition = false;
            PositionDirection = 0;
            If RENKO_SHOW_DEBUG Then Print(&quot;&lt;&lt;&lt; SHORT EXIT: Stop EOB &gt;&gt;&gt;&quot;);
        End;

    End;

    // Max adverse bricks exit
    If MAX_ADVERSE_BRICKS &gt; 0 And ConsecutiveAdverseBricks &gt;= MAX_ADVERSE_BRICKS Then Begin

        If PositionDirection = 1 Then Begin
            Sell (&quot;LX_MaxAdverse&quot;) Next Bar at Market;
            InPosition = false;
            PositionDirection = 0;
            If RENKO_SHOW_DEBUG Then
                Print(&quot;&lt;&lt;&lt; LONG EXIT: Max Adverse Bricks (&quot;, ConsecutiveAdverseBricks:0:0, &quot;) &gt;&gt;&gt;&quot;);
        End;

        If PositionDirection = -1 Then Begin
            BuyToCover (&quot;SX_MaxAdverse&quot;) Next Bar at Market;
            InPosition = false;
            PositionDirection = 0;
            If RENKO_SHOW_DEBUG Then
                Print(&quot;&lt;&lt;&lt; SHORT EXIT: Max Adverse Bricks (&quot;, ConsecutiveAdverseBricks:0:0, &quot;) &gt;&gt;&gt;&quot;);
        End;

    End;

End;


{ ============================================ }
{ END OF STRATEGY                             }
{ ============================================ }
</pre>
        </div>
    </div>
</body>
</html>
