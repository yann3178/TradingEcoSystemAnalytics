<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATS_Strategy_v0.8 - Strategy Analysis</title>
    
    <style>
        :root {
            --primary: #3498db;
            --success: #27ae60;
            --warning: #f39c12;
            --danger: #e74c3c;
            --dark: #2c3e50;
            --light: #ecf0f1;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: var(--primary);
            text-decoration: none;
            font-weight: 500;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        h1 {
            color: var(--dark);
            border-bottom: 3px solid var(--primary);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        h2 {
            color: #34495e;
            margin-top: 30px;
            margin-bottom: 15px;
            border-left: 4px solid var(--primary);
            padding-left: 15px;
        }
        
        .header-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .info-box {
            background: var(--light);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--primary);
        }
        
        .info-box strong {
            display: block;
            color: var(--dark);
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        .badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            color: white;
            font-size: 0.85em;
            font-weight: 500;
        }
        
        .badge-yes {
            background: var(--success);
        }
        
        .badge-no {
            background: #95a5a6;
        }
        
        .score {
            font-size: 1.5em;
            font-weight: bold;
        }
        
        .score-high {
            color: var(--success);
        }
        
        .score-medium {
            color: var(--warning);
        }
        
        .score-low {
            color: var(--danger);
        }
        
        .section {
            margin: 25px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .analysis-list {
            margin: 10px 0 10px 20px;
        }
        
        .analysis-list li {
            margin: 8px 0;
        }
        
        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .patterns-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }
        
        .pattern-tag {
            background: var(--light);
            padding: 5px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }
        
        .links-section {
            margin-top: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            color: white;
        }
        
        .links-section a {
            color: white;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            .header-grid {
                grid-template-columns: 1fr;
            }
            
            body {
                padding: 10px;
            }
            
            .container {
                padding: 15px;
            }
        }
    </style>
    
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Retour √† la liste</a>
        
        <h1>üìä ATS_Strategy_v0.8</h1>
        
        <div class="header-grid">
            <div class="info-box">
                <strong>Type</strong>
                <span class="badge" style="background-color: #3498db">BREAKOUT</span>
            </div>
            <div class="info-box">
                <strong>Sous-type</strong>
                <span>Bollinger</span>
            </div>
            <div class="info-box">
                <strong>Score Qualit√©</strong>
                <span class="score score-high">8/10</span>
            </div>
            <div class="info-box">
                <strong>Score Complexit√©</strong>
                <span class="score score-high">9/10</span>
            </div>
        </div>
        
        <div class="section">
            <h2>üìù R√©sum√©</h2>
            <p>This is a sophisticated <strong>multi-timeframe breakout strategy</strong> that analyzes 6 timeframes (15min to Monthly) using <strong>Bollinger Band phases</strong> and <strong>support/resistance clusters</strong>. It enters positions on two main scenarios: <strong>UC1</strong> (expansion breakouts from P2H Bollinger phase) and <strong>UC2</strong> (signal-based entries from moving average crossovers). The system includes comprehensive <strong>pattern filtering</strong> and <strong>multi-horizon risk management</strong>.</p>
        </div>
        
        <div class="section">
            <h2>üéØ Conditions d'Entr√©e</h2>
            <p><strong>LONG Entries:</strong>
‚Ä¢ <strong>UC1 Scenario:</strong> Bollinger Band expansion (P2H phase) on UT1 or UT2 with valid duration filter
‚Ä¢ <strong>UC2 Scenario:</strong> Moving average signals (XH, NXH, XPH) within recent distance
‚Ä¢ <strong>Pattern Filters:</strong> Must pass PatternNeutralFast conditions and avoid negative directional patterns
‚Ä¢ <strong>Cluster Requirement:</strong> Support cluster detected (3+ levels within param_ClusterPips)
‚Ä¢ <strong>Session Filter:</strong> Within trading hours (0110-2200) avoiding pause periods
‚Ä¢ <strong>ADX Filter:</strong> ADX(7) &gt; 20 for trend strength
‚Ä¢ <strong>Multi-Horizon Check:</strong> All daily/weekly/monthly profit limits respected

<strong>SHORT Entries:</strong>
‚Ä¢ Currently disabled in this version (param_playShort capability exists but no short logic implemented)</p>
        </div>
        
        <div class="section">
            <h2>üö™ Conditions de Sortie</h2>
            <p><strong>Partial Profit Taking:</strong>
‚Ä¢ Sell 50% at first resistance level when 2 contracts held
‚Ä¢ Remaining contract targets second resistance level

<strong>Trailing Stop:</strong>
‚Ä¢ SetTrailingStop_pt(60) = 60 points trailing stop on remaining position

<strong>Scenario-Specific Exits:</strong>
‚Ä¢ UC1 trades exit on Bollinger contraction signals

<strong>Profit Protection:</strong>
‚Ä¢ If MaxPositionProfit &gt;= 6000 and current profit drops below 80% of max, exit immediately

<strong>Time-Based Exits:</strong>
‚Ä¢ Close all positions on Friday if param_CloseOnFriday = 1
‚Ä¢ Close at session end if param_ExitOnSessionClose = 1
‚Ä¢ Maximum 5 days in trade limit</p>
        </div>
        
        <div class="header-grid">
            <div class="info-box">
                <strong>Stop Loss</strong>
                <ul class="analysis-list"><li>SetStopLoss_pt(<strong>100</strong>) = 100 in <strong>points</strong></li></ul>
            </div>
            <div class="info-box">
                <strong>Take Profit</strong>
                <ul class="analysis-list"><li>Partial: First resistance level or close + <strong>70 points</strong>
‚Ä¢ Final: SetTrailingStop_pt(<strong>60</strong>) = 60 <strong>points</strong> trailing stop</li></ul>
            </div>
            <div class="info-box">
                <strong>Exit On Close</strong>
                <span class="badge badge-yes">YES</span>
            </div>
            <div class="info-box">
                <strong>Time Exit</strong>
                <span class="badge badge-yes">YES</span>
            </div>
        </div>
        
        <div class="section">
            <h2>üîß Patterns & Fonctions</h2>
            <div class="patterns-list"><span class="pattern-tag">PatternNeutralFast(12)</span><span class="pattern-tag">PatternNeutralFast(55)</span><span class="pattern-tag">PatternNeutralFast(46)</span><span class="pattern-tag">PatternNeutralFast(56)</span><span class="pattern-tag">PatternDirectionalFast(52)</span><span class="pattern-tag">PatternDirectionalFast(35)</span><span class="pattern-tag">PatternNeutralFast(53)</span><span class="pattern-tag">PatternDirectionalFast(16)</span><span class="pattern-tag">ADX(7)</span></div>
            <p><strong>Nombre de patterns:</strong> 9</p>
        </div>
        
        <div class='section'><h2>üîç D√©tails des Patterns</h2><p><strong>PatternNeutralFast(12):</strong> body5d &lt; 0.75 * (highd5-lowd1)
‚Ä¢ Meaning: 5-day body less than 75% of 5-day range from high to low
‚Ä¢ Indicates: Moderate consolidation pattern
‚Ä¢ Trading use: Allows entries during controlled volatility

<strong>PatternNeutralFast(55):</strong> (highd0&gt;(lowd0+lowd0*1*0.01))
‚Ä¢ Meaning: Current high exceeds low plus 1% of low value
‚Ä¢ Indicates: Minimum daily range requirement
‚Ä¢ Trading use: Ensures adequate volatility for trade

<strong>PatternNeutralFast(46):</strong> ((opend0-lowd0)&gt; ((opend1-lowd1)*3))
‚Ä¢ Meaning: Current open-to-low distance exceeds 3x previous period
‚Ä¢ Indicates: Significant gap or volatility expansion
‚Ä¢ Trading use: Filters for strong momentum moves

<strong>PatternDirectionalFast(52):</strong> highd1&lt;highd2 and lowd1&lt;lowd2
‚Ä¢ Meaning: Previous bar&#39;s high and low both below prior bar
‚Ä¢ Indicates: Inside bar pattern (consolidation)
‚Ä¢ Trading use: Filters for breakout setups after consolidation

<strong>PatternDirectionalFast(35):</strong> ((highd0-opend0)&gt; ((highd1-opend1)*1.5))
‚Ä¢ Meaning: Current high-open distance exceeds 1.5x previous period
‚Ä¢ Indicates: Strong upward momentum within bar
‚Ä¢ Trading use: Confirms bullish intrabar action</p></div>
        
        <div class="section">
            <h2>‚≠ê Analyse Qualit√©</h2>
            <p><strong>STRENGTHS:</strong>
‚Ä¢ <strong>Multi-timeframe analysis</strong> across 6 timeframes provides comprehensive market view
‚Ä¢ <strong>Sophisticated risk management</strong> with daily/weekly/monthly profit limits and drawdown controls
‚Ä¢ <strong>Support/resistance cluster detection</strong> improves entry timing and reduces false signals
‚Ä¢ <strong>Bollinger Band phase analysis</strong> helps identify optimal market conditions for breakouts
‚Ä¢ <strong>Pattern filtering system</strong> with 150+ patterns reduces poor-quality setups
‚Ä¢ <strong>Partial profit taking</strong> and trailing stops optimize trade management
‚Ä¢ <strong>Session filtering</strong> avoids low-liquidity periods

<strong>WEAKNESSES:</strong>
‚Ä¢ <strong>Extremely complex code</strong> with high computational overhead and potential for bugs
‚Ä¢ <strong>Over-optimization risk</strong> with numerous parameters that may not work in different market conditions
‚Ä¢ <strong>No short trading</strong> in current implementation limits profit opportunities
‚Ä¢ <strong>Hardcoded timeframe assumptions</strong> may not adapt well to different instruments
‚Ä¢ <strong>Pattern logic complexity</strong> makes it difficult to understand why trades are taken or rejected
‚Ä¢ <strong>Multiple exit conditions</strong> could conflict and create unexpected behavior

<strong>RISK MANAGEMENT:</strong>
‚Ä¢ <strong>Excellent multi-horizon controls</strong> prevent catastrophic losses across different time periods
‚Ä¢ <strong>Reasonable stop loss</strong> at 100 points with trailing mechanism
‚Ä¢ <strong>Position sizing</strong> with 2-contract partial profit approach
‚Ä¢ <strong>Maximum trade duration</strong> prevents extended drawdowns
‚Ä¢ <strong>Profit protection mechanism</strong> locks in gains when significant profits achieved

<strong>OVERALL:</strong>
This is a <strong>highly sophisticated institutional-grade strategy</strong> with excellent risk management but <strong>excessive complexity</strong>. The multi-timeframe approach and comprehensive filtering show advanced understanding, but the system may be <strong>over-engineered</strong> and difficult to maintain. The <strong>missing short side</strong> and complex pattern interactions could limit performance. Best suited for <strong>experienced algorithmic traders</strong> with significant computational resources and thorough backtesting capabilities.</p>
        </div>
        
        
        
        <h2>üíª Code Source</h2>
        <div class="code-block"><pre>{ ALGORITHME ATS 
Signaux: UC1, UC2.
Bons resultats, identiques avec FDXM.

Objectif v0.8: affiner le distingo UC1 et UC2 sur des parametres distincts pour pouvoir les optimiser chacun + Activation des parametres close end of day et close on friday .

Reste a faire et/ou tester:
- Quid de cumuler les signaux UC1 et UC2 plutot que de les exclure mutuellement ? (V0.9?)



FAIT:
[X] : Calcul des UTs et leurs indicateurs
[X] : Calcul des Supports et Resisitances (pas ajoute de condition sur la duree non perce yet). Les noms de Supports et resistances non geres pour l&#39;instant
[X] : Detection des Cluster de Support ou Resistance (doit verifier si meme methode que Pinescript pour definir le cluster). Nom des supports compopsant le cluster non gere pour l&#39;instant
[X] : Calcul des phases de bollinger : calcul un peu simplifie a causes de limitation sur la gestion des historiques sur UT... a creuser plus tard car c est fondationnel.
[X] : Affichage de la configuration ATS
[X] : Ajout des filtres sur Patterns UA
[X] : Ajout Money Management: Loss / Profit Max Journalier / Hebdo / Monthly
[X] : Affichage Situation Multi-Horizon Journalier/ Hebdo / Monthly
[X] : UC1: Ajout d&#39;un critere pour ne pas rentrer trop tard dans une P2H (reste a adapter pour UT2)
[X] : Profit Protector Option: Option de protection de profit sur Trade (PFloor, PRatio)
[ ] : Extreme Volatility KillSwitch



RESTE A FAIRE SUR LES FONDATIONS - Target : 02/06/25
[X] : Phases: fiabiliser (ca prendra du temps mais il faut traiter ca car base de bcp de chose)
[X] : CALCUL DES SIGNAUX (NXH, ...) ca semble ne pas marcher
[X] : S&amp;R : Ajouter les ATH + PDL/PDH + PWL/PWH? etc?  
[X] : GERER LES NOMS DES S&amp;R ?
[X] : BUG : MAUVAIS CALCUL DU SAR DANS TOUTES LES UTs????
[ ] : S&amp;R : Ajouter la condition &quot;non perce depuis 5/10 periodes&quot;
[X] : OPTIMISER CODE POUR PERFORMANCE AVEC AIDE DE CLAUDE / GPT
		OPTIMISATIONS APPLIQU?ES:
		- Suppression de toutes les variables SAR redondantes
		- Factorisation des calculs Bollinger
		- ?limination des variables de phases locales inutiles
		- Rationalisation des calculs d&#39;indicateurs
		- Suppression des variables inutilis?es
		- Structure modulaire claire
		- Affichage complet restaur?

[X] : Ajouter les signaux XPH / XPB ? (croisement SAR / M20?)
[ ] : Ajouter des criteres de pentes ou de cassure de canal pour les P2H et les P1 et/ou les XH et NXH



ETAPES SUIVANTES APRES FONDATIONS - Target : 15/06/25
[P] : DETECTION DES SIGNAUX : UC1 et UC2
[X] : ENTREE EN TRADE AVEC SIMPLES TP1/SL/BE DANS UN PREMIER TEMPS
[X] : Introduction du TP2 + Trailing Stop?
[X] : Introduction de Conditions de sorties possibles TBC
[ ] : GESTION DES OBJECTIFS DYNAMIQUES DANS UN DEUXIEME TEMPS ET/OU MODULE STATISTIQUE MAE/MFE POUR SL/TP OPTIMUMS ??

ETAPES D&#39;AMELIORATION: - 30/06/25
[X] : Never make a winner a looser
[X] : No Trades on Friday, No Trade on America open session or Europe close or Europe open, no trade before 7:00 or after 20:00/21:50
[ ] : Add Imbalance detection (retracement, ...) and adapt strategy ?
[ ] : Add Gap management to adapt strategy?


V0.8 -  PARAMETRES OPTIMISES LE 3/06/2025
In Sample: 01/01/2008 a 2020
OOS 	   : 01/01/2020 a 03/06/2025


Name                        Value
=======================================
SessionStartTimeA           110
sessionEndTimeA             230
PinNeutJC1Yes              12
PinNeutJC1Yes2             41
PinNeutJC1No               1
PinNeutJC1No2              56
PinDirJC1Yes               152
PinDirJC1No                19
PinNeutJC2Yes              55
PinNeutJC2No               48
PinNeutJC2No2              56
PinDirJC2Yes               134
PinDirJC2No                23
noTradingMonth             0
noTradingDay               6
param_playLong             true
param_playShort            true
param_uc1                  true
param_uc2                  true
param_ClusterPips          50
param_rt1                  0.25
param_rt2                  15
param_SLLong               100
param_TPLong               70
param_SLShort              100
param_TPShort              200
param_BEEnabled            true
param_BEActivationPct      100
param_TrailingSL           60
session_StartTime          110
session_EndTime            2200
session_PauseStart1        300
session_PauseEnd1          1000
session_PauseStart2        1400
session_PauseEnd2          1500
session_PauseStart3        1700
session_PauseEnd3          1800
param_MaxDaysInTrade       5
param_CloseOnFriday        1
param_ExitOnSessionClose   1
myContract                 1


STRATEGY PERFORMANCE FROM 01/01/2008 TO 3/06/2025

Metric                              All Trades
========================================================
Net Profit                          ?854,697.00
Gross Profit                        ?4,301,190.72
Gross Loss                          (?3,446,493.72)
Adjusted Net Profit                 ?666,319.22
Adjusted Gross Profit               ?4,215,981.03
Adjusted Gross Loss                 (?3,549,661.81)
Select Net Profit                   (?93,569.08)
Select Gross Profit                 ?3,347,617.12
Select Gross Loss                   (?3,441,186.20)
Account Size Required               ?50,468.88
Return on Account                   1693.51%
Return on Initial Capital           284.9%
Max Strategy Drawdown               (?53,675.52)
Max Strategy Drawdown (%)           (11.12%)
Max Close To Close Drawdown         (?50,468.88)
Max Close To Close Drawdown (%)     (10.18%)
Return on Max Strategy Drawdown     15.92
Profit Factor                       1.25
Adjusted Profit Factor              1.19
Select Profit Factor                (0.97)
Max # Contracts Held                2
Slippage Paid                       ?10,600.00
Commission Paid                     ?9,328.00
Open Position P/L                   n/a
Annual Rate of Return               21.62%
Monthly Rate of Return              1.8%
Buy Hold Return                     ?550,281.49
Avg Monthly Return                  ?5,375.45
Monthly Return StdDev               ?13,473.62
Total # of Trades                   3664
Percent Profitable                  69.54%



Total Trade Analysis
========================================================
Metric                              All Trades
========================================================
Total # of Trades                   3664
Total # of Open Trades              0
Number Winning Trades               2548
Number Losing Trades                1116
Percent Profitable                  69.54%
Avg Trade (win loss)                ?233.27
Average Winning Trade               ?1,688.07
Average Losing Trade                (?3,088.26)
Ratio Avg Win / Avg Loss            (0.55)
Largest Winning Trade               ?11,945.24
Largest Losing Trade                (?5,307.52)
Avg # Bars in All Trades            27.3
Avg # Bars in Winning Trades        27.5
Avg # Bars in Losing Trades         26.9
Avg # Bars in Even Trades           n/a
Avg # Bars Between All Trades       36.5
Avg # Bars Between Winning Trades   38
Avg # Bars Between Losing Trades    41.3
Avg # Bars Between Even Trades      n/a



Annual Period Analysis
================================================================================
Period    Profit ?     %      Avg ?    Gross Profit  Gross Loss     # Trades  % Profitable
================================================================================
2025      ?54,147.80   4.92%  ?320.40  ?243,169.96   (?189,022.16)  169       71.6%
2024      ?79,500.08   7.79%  ?225.85  ?421,700.88   (?342,200.80)  352       70.17%
2023      ?75,653.12   8%     ?245.63  ?372,967.20   (?297,314.08)  308       70.13%
2022      ?111,919.20  13.43% ?254.94  ?571,144.88   (?459,225.68)  439       74.49%
2021      ?104,107.60  14.27% ?300.02  ?421,193.36   (?317,085.76)  347       70.32%
2020      ?80,120.20   12.34% ?228.26  ?455,669.12   (?375,548.92)  351       72.36%
2019      ?87,430.96   15.56% ?319.09  ?315,444.84   (?228,013.88)  274       70.07%
2018      (?2,310.92)  (0.41%) (?10.27) ?235,840.68   (?238,151.60)  225       64.44%
2017      ?42,866.92   8.22%  ?223.27  ?182,862.80   (?139,995.88)  192       63.54%
2016      ?53,261.44   11.38% ?221.92  ?268,687.72   (?215,426.28)  240       67.92%
2015      ?95,321.40   25.58% ?368.04  ?339,019.72   (?243,698.32)  259       73.75%
2014      ?37,809.44   11.32% ?190.38  ?198,082.72   (?160,183.28)  197       67.01%
2013      ?15,471.80   4.85%  ?81.86   ?161,987.92   (?146,516.12)  189       63.49%
2012      ?19,307.96   6.44%  ?158.26  ?113,418.92   (?94,110.96)   122       60.66%
}

{


}

{ ALGORITHME ATS - VERSION OPTIMIS?E AVEC AFFICHAGE COMPLET

}

{===========================================================}
{                   D?CLARATIONS GLOBALES                   }
{===========================================================}

//Michael formula calculation begin
Input:SessionStartTimeA(0110), sessionEndTimeA(2200); //Set here your session time!
array:ohlcvalues[23](0), adxCalcValues[3](0);
var:IsStartOfSession(false);


IsStartOfSession=_OHLCMulti5(SessionStartTimeA,sessionEndTimeA,ohlcvalues);
//Michael formula calculation end


{Definition des constantes pour les indices des timeframes}
Vars: 
    TF_15MIN(1), TF_1HOUR(2), TF_4HOUR(3), TF_DAILY(4), TF_WEEKLY(5), TF_MONTHLY(6),
    timeframeIdx(0), indicatorIdx(0), dataStream(0), 
    currentPrice(0);

{Definition des constantes pour les indices des variables}
Vars:
    IDX_M7(1), IDX_M20(2), IDX_BBH(3), IDX_BBL(4), IDX_SAR(5),
    IDX_OGGY1(6), IDX_OGGY2(7), IDX_OGGY3(8),
    IDX_JACK1(9), IDX_JACK2(10), IDX_JACK3(11),
    IDX_CLOSEST_SUPPORT(12), IDX_CLOSEST_RESISTANCE(13);

{Tableaux pour stocker les valeurs numeriques}
Arrays:
    UTData[6,13](0), {6 timeframes x 13 variables numeriques}
    IndicatorsValueArray[6,11,2](0), {6 timeframes x 11 indicateurs x 2 (valeur, au-dessus/en-dessous)}
    IndicatorsNameArray[6,11,2](&quot;&quot;);
   
{Tableaux pour les variables de type string}
Arrays:
    UTLastSignalCode[6](&quot;NC&quot;),
    UTBollPhase[6](&quot;P1&quot;),
    signalHaussier[6](&quot;&quot;), 
    signalBaissier[6](&quot;&quot;);

{Variables pour les distances des signaux}
Arrays:
    UTLastSignalDistance[6](9999);

{Tableau pour stocker les noms des timeframes}
Arrays:
    UTNames[6](&quot;&quot;);

{Tableau pour stocker les durees des P2H}
Arrays:
    UTDureeP2H[6](0);                  // Compteur de barres en P2H par timeframe

{Variables et tableaux pour la Grande Fenetre (GF)}
Vars:
    GF_ClosestSupport(0), 
    GF_ClosestResistance(0),
    GF_isSupportCluster(false), 
    GF_isResistanceCluster(false),
    GF_SupportName(&quot;&quot;), 
    GF_ResistanceName(&quot;&quot;),
    SupportClusterCount(0), 
    ResistanceClusterCount(0),
    clusterIdx(0);

{Tableaux pour la Grande Fenetre}
Arrays:
    GF_Supports[100](0), 
    GF_Resistances[100](0),
    GF_AllIndicatorsValue[100](0), 
    GF_AllIndicatorsName[100](&quot;&quot;);

{Variables pour les signaux de la Grande Fenetre}
Vars: 
    GF_SignauxHaussiers(&quot;&quot;), 
    GF_NbSignauxHaussiersRecents(0),
    GF_SignauxBaissiers(&quot;&quot;), 
    GF_NbSignauxBaissiersRecents(0);

{Variables pour les scenarios de trading}
Vars: 
    GF_PossibleScenarioLong(&quot;&quot;),
    GF_CodeScenarioLong(&quot;&quot;),
    GF_PossibleScenarioShort(&quot;&quot;),
    GF_CodeScenarioShort(&quot;&quot;),
    GF_NbScenarioDetecte(0);
    
{ 2. VARIABLES DE TRACKING MULTI-HORIZONS }
Vars:
    { === TRACKING JOURNALIER === }
    dailyProfit(0), dailyTradingEnabled(true), lastDailyResetDate(0),
    dailyStartProfit(0), dailyTradeCount(0),
    
    { === TRACKING HEBDOMADAIRE === }
    weeklyProfit(0), weeklyTradingEnabled(true), lastWeeklyResetDate(0),
    weeklyStartProfit(0), weeklyTradeCount(0), currentWeek(0),
    
    { === TRACKING MENSUEL === }
    monthlyProfit(0), monthlyTradingEnabled(true), lastMonthlyResetDate(0), 
    monthlyStartProfit(0), monthlyTradeCount(0), currentMonth(0),
    
    { === VARIABLES COMMUNES === }
    globalTradingEnabled(true),        // Flag global (AND de tous les horizons)
    lastTradeExitProfit(0);
{===========================================================}
{        PARAMETRES DE CONFIGURATION UTILISATEUR            }
{===========================================================}

{Parametres Affichage}
Inputs:
	DisplayATSConfiguration(0),
	DisplayPerfo (1);

{Parametres de direction et strategie}
Inputs:
    LONG_UC1_PtnNeut_Yes(12), LONG_UC1_PtnNeut_Yes2(55),LONG_UC1_PtnNeut_No(46), LONG_UC1_PtnNeut_No2(56),LONG_UC1_PtnDir_Yes(52),LONG_UC1_PtnDir_No(35), //optimize Neutral from 1 to 55 (55=true, 56=false). Directional from -152 to 152 (152=true, 153=false)
    LONG_UC2_PtnNeut_Yes(55),LONG_UC2_PtnNeut_No(53), LONG_UC2_PtnNeut_No2(56),LONG_UC2_PtnDir_Yes(55),LONG_UC2_PtnDir_No(16), //optimize Neutral from 1 to 55 (55=true, 56=false). Directional from -152 to 152 (152=true, 153=false)

    noTradingMonth(0), noTradingDay(6),
    param_playLong(true), 
    param_playShort(true),
    param_uc1 (1),
    param_uc2 (1);
    
Inputs:
    param_MinDureeP2H(1),              // Dur?e minimum en P2H avant signal (en barres)
    param_MaxDureeP2H(20),             // Dur?e maximum en P2H pour ?viter signaux tardifs
    param_EnableDureeP2HFilter(true);  // Activer/d?sactiver le filtre dur?e P2H

Inputs:
    param_exit_uc1 (0);

{Parametres d&#39;analyse technique}
Inputs:
    param_ClusterPips(5);

{Parametres de gestion du risque}
Inputs:

    param_SLLong(100), 
    param_TPLong(70), 
    param_TrailingSL (60);

{Parametres de Money Management}    
Inputs:
    { === PARAMETRES JOURNALIERS === }
    param_DailyLossLimit(-5000),        // Limite de perte journali?re
    param_DailyProfitTarget(1000),     // Objectif de profit journalier
    param_EnableDailyLossFilter(1), 
    param_EnableDailyProfitTarget(0),
    param_DailyResetHour(0000),        // Reset journalier
    
    { === PARAMETRES HEBDOMADAIRES === }
    param_WeeklyLossLimit(-12500),      // Limite de perte hebdomadaire
    param_WeeklyProfitTarget(3000),    // Objectif de profit hebdomadaire
    param_EnableWeeklyLossFilter(1),
    param_EnableWeeklyProfitTarget(0),
    param_WeeklyResetDay(1),           // 1=Dimanche, 2=Lundi, etc.
    
    { === PARAMETRES MENSUELS === }
    param_MonthlyLossLimit(-20000),     // Limite de perte mensuelle
    param_MonthlyProfitTarget(8000),   // Objectif de profit mensuel
    param_EnableMonthlyLossFilter(1),
    param_EnableMonthlyProfitTarget(0),
    param_MonthlyResetDay(1);          // Jour du mois pour reset (1er)    

{Parametres de session de trading}
Inputs:
    session_StartTime(0100), 
    session_EndTime(2000), 
    session_PauseStart1(800), 
    session_PauseEnd1(1000),
    session_PauseStart2(2300), 
    session_PauseEnd2(2300);
    
{Parametres de gestion des positions}
Inputs:
    param_MaxDaysInTrade(5), 
    param_CloseOnFriday(1), 
    param_ExitOnSessionClose(1), 
    myContract(2);

{Variables de position consolid?es}
Vars:
    positionOpen(false), 
    positionType(0), 
    entryPrice(0),
    stopPrice(0), 
    targetPrice(0), 
    entryDate(0), 
    entryTime(0),
    breakEvenActive(false), 
    currentProfit(0);

{Variables de session consolid?es}
Vars:
    currentTime(0), 
    currentDate(0), 
    daysSinceEntry(0),
    inTradingHours(false), 
    inPauseTime(false), 
    isFriday(false),
    shouldExit(false), 
    canTradeLong(false), 
    canTradeShort(false);

{Variables pour calculs Bollinger factoris?es}
Vars:
    bbMiddle(0), bbUpper(0), bbLower(0), bbStdDev(0);

{===========================================================}
{                INITIALISATION DU SYST?ME                  }
{===========================================================}

Once Begin
    {Definir les noms des timeframes}
    UTNames[TF_15MIN] = &quot;15min&quot;;
    UTNames[TF_1HOUR] = &quot;60min&quot;;
    UTNames[TF_4HOUR] = &quot;4H&quot;;
    UTNames[TF_DAILY] = &quot;Daily&quot;;
    UTNames[TF_WEEKLY] = &quot;Weekly&quot;;
    UTNames[TF_MONTHLY] = &quot;Monthly&quot;;
    
    {Initialisation des tableaux de signaux}
    signalHaussier[1] = &quot;XH-M7-M20&quot;; 
    signalHaussier[2] = &quot;xH M7-M20&quot;; 
    signalHaussier[3] = &quot;NXH&quot;; 
    signalHaussier[4] = &quot;XPH&quot;; 
    signalHaussier[5] = &quot;XPH2&quot;;
    
    signalBaissier[1] = &quot;XB-M7-M20&quot;; 
    signalBaissier[2] = &quot;xB M7-M20&quot;; 
    signalBaissier[3] = &quot;NXB&quot;; 
    signalBaissier[4] = &quot;XPB&quot;; 
    signalBaissier[5] = &quot;XPB2&quot;;

    Print(&quot;---- Initialisation du systeme ----&quot;);
    Print(&quot;Date de demarrage:&quot;, Date, &quot; Heure:&quot;, Time);
End;

{ ============== GESTION DES RESETS MULTI-HORIZONS ============== }

{ === RESET JOURNALIER === }
If Date &lt;&gt; lastDailyResetDate Then Begin // OR (Time = param_DailyResetHour AND Time[1] &lt;&gt; param_DailyResetHour) Then Begin
    If dailyProfit &lt;&gt; 0 Then Begin
        Print(&quot;=== BILAN JOURNALIER ===&quot;);
        Print(&quot;Date: &quot;, lastDailyResetDate, &quot; | Profit: &quot;, dailyProfit, &quot; | Trades: &quot;, dailyTradeCount);
    End;
    
    dailyProfit = 0;
    dailyTradingEnabled = true;
    dailyTradeCount = 0;
    lastDailyResetDate = Date;
    dailyStartProfit = NetProfit;
    
    Print(&quot;Reset journalier - Date: &quot;, Date);
End;

{ === RESET HEBDOMADAIRE === }
If DayOfWeek(Date) = param_WeeklyResetDay AND DayOfWeek(Date[1]) &lt;&gt; param_WeeklyResetDay Then Begin
    If weeklyProfit &lt;&gt; 0 Then Begin
        Print(&quot;=== BILAN HEBDOMADAIRE ===&quot;);
        Print(&quot;Semaine termin?e | Profit: &quot;, weeklyProfit, &quot; | Trades: &quot;, weeklyTradeCount);
        //Print(&quot;Status: &quot;, IFF(weeklyTradingEnabled, &quot;ACTIF&quot;, &quot;BLOQUE&quot;));
    End;
    
    weeklyProfit = 0;
    weeklyTradingEnabled = true;
    weeklyTradeCount = 0;
    lastWeeklyResetDate = Date;
    weeklyStartProfit = NetProfit;
    currentWeek = currentWeek + 1;
    
    Print(&quot;=== NOUVELLE SEMAINE ===&quot;);
    Print(&quot;Semaine #&quot;, currentWeek, &quot; | Reset le: &quot;, Date);
End;

{ === RESET MENSUEL === }
If Month(Date) &lt;&gt; Month(Date[1]) Then Begin //DayOfMonth(Date) = param_MonthlyResetDay AND DayOfMonth(Date[1]) &lt;&gt; param_MonthlyResetDay Then Begin
    If monthlyProfit &lt;&gt; 0 Then Begin
        Print(&quot;=== BILAN MENSUEL ===&quot;);
        Print(&quot;Mois: &quot;, Month(Date[1]), &quot;/&quot;, Year(Date[1]));
        Print(&quot;Profit mensuel: &quot;, monthlyProfit, &quot; | Trades: &quot;, monthlyTradeCount);
        //Print(&quot;Status final: &quot;, IFF(monthlyTradingEnabled, &quot;ACTIF&quot;, &quot;BLOQUE&quot;));
    End;
    
    monthlyProfit = 0;
    monthlyTradingEnabled = true;
    monthlyTradeCount = 0;
    lastMonthlyResetDate = Date;
    monthlyStartProfit = NetProfit;
    currentMonth = Month(Date);
    
    Print(&quot;=== NOUVEAU MOIS ===&quot;);
    Print(&quot;Mois: &quot;, Month(Date), &quot;/&quot;, Year(Date), &quot; | Reset le: &quot;, Date);
End;


{ 4. CALCUL DES PROFITS EN TEMPS REEL }

{ ============== CALCUL DES PROFITS MULTI-HORIZONS ============== }
{ Calcul base sur NetProfit }
dailyProfit = NetProfit - dailyStartProfit;
weeklyProfit = NetProfit - weeklyStartProfit;
monthlyProfit = NetProfit - monthlyStartProfit;

{ Tracking des trades ferm?s }
If MarketPosition = 0 AND MarketPosition[1] &lt;&gt; 0 Then Begin
    lastTradeExitProfit = NetProfit - NetProfit[1];
    
    { Mise a jour des compteurs si trade ferme dans la periode courante }
    If Date = lastDailyResetDate Then
        dailyTradeCount = dailyTradeCount + 1;
    If Date &gt;= lastWeeklyResetDate Then
        weeklyTradeCount = weeklyTradeCount + 1;
    If Date &gt;= lastMonthlyResetDate Then
        monthlyTradeCount = monthlyTradeCount + 1;
        
    Print(&quot;Trade ferm? - P&amp;L: &quot;, lastTradeExitProfit);
    Print(&quot;Profits - Jour: &quot;, dailyProfit, &quot; | Semaine: &quot;, weeklyProfit, &quot; | Mois: &quot;, monthlyProfit);
End;

{ 5. VERIFICATION DES LIMITES MULTI-HORIZONS }

{ ============== VERIFICATION DES LIMITES JOURNALIERES ============== }
If param_EnableDailyLossFilter=1 AND dailyProfit &lt;= param_DailyLossLimit AND dailyTradingEnabled Then Begin
    dailyTradingEnabled = false;
    Print(&quot;*** LIMITE JOURNALIERE ATTEINTE ***&quot;);
    Print(&quot;Profit jour: &quot;, dailyProfit, &quot; | Limite: &quot;, param_DailyLossLimit);
    Print(&quot;TRADING SUSPENDU jusqu&#39;a demain&quot;);
End;

If param_EnableDailyProfitTarget=1 AND dailyProfit &gt;= param_DailyProfitTarget AND dailyTradingEnabled Then Begin
    dailyTradingEnabled = false;
    Print(&quot;*** OBJECTIF JOURNALIER ATTEINT ***&quot;);
    Print(&quot;Profit jour: &quot;, dailyProfit, &quot; | Objectif: &quot;, param_DailyProfitTarget);
    Print(&quot;TRADING SUSPENDU jusqu&#39;? demain&quot;);
End;

{ ============== VERIFICATION DES LIMITES HEBDOMADAIRES ============== }
If param_EnableWeeklyLossFilter=1 AND weeklyProfit &lt;= param_WeeklyLossLimit AND weeklyTradingEnabled Then Begin
    weeklyTradingEnabled = false;
    Print(&quot;*** LIMITE HEBDOMADAIRE ATTEINTE ***&quot;);
    Print(&quot;Profit semaine: &quot;, weeklyProfit, &quot; | Limite: &quot;, param_WeeklyLossLimit);
    Print(&quot;TRADING SUSPENDU jusqu&#39;? la semaine prochaine&quot;);
End;

If param_EnableWeeklyProfitTarget=1 AND weeklyProfit &gt;= param_WeeklyProfitTarget AND weeklyTradingEnabled Then Begin
    weeklyTradingEnabled = false;
    Print(&quot;*** OBJECTIF HEBDOMADAIRE ATTEINT ***&quot;);
    Print(&quot;Profit semaine: &quot;, weeklyProfit, &quot; | Objectif: &quot;, param_WeeklyProfitTarget);
    Print(&quot;TRADING SUSPENDU jusqu&#39;a la semaine prochaine&quot;);
End;

{ ============== VERIFICATION DES LIMITES MENSUELLES ============== }
If param_EnableMonthlyLossFilter=1 AND monthlyProfit &lt;= param_MonthlyLossLimit AND monthlyTradingEnabled Then Begin
    monthlyTradingEnabled = false;
    Print(&quot;*** LIMITE MENSUELLE ATTEINTE ***&quot;);
    Print(&quot;Profit mois: &quot;, monthlyProfit, &quot; | Limite: &quot;, param_MonthlyLossLimit);
    Print(&quot;TRADING SUSPENDU jusqu&#39;au mois prochain&quot;);
End;

If param_EnableMonthlyProfitTarget=1 AND monthlyProfit &gt;= param_MonthlyProfitTarget AND monthlyTradingEnabled Then Begin
    monthlyTradingEnabled = false;
    Print(&quot;*** OBJECTIF MENSUEL ATTEINT ***&quot;);
    Print(&quot;Profit mois: &quot;, monthlyProfit, &quot; | Objectif: &quot;, param_MonthlyProfitTarget);
    Print(&quot;TRADING SUSPENDU jusqu&#39;au mois prochain&quot;);
End;

{ 6. CALCUL DU FLAG GLOBAL DE TRADING }

{ ============== FLAG GLOBAL DE TRADING ============== }
{ Le trading n&#39;est autorise que si TOUS les horizons sont OK }
globalTradingEnabled = dailyTradingEnabled AND weeklyTradingEnabled AND monthlyTradingEnabled;

{ Fermeture forcee si l&#39;un des horizons est bloque }
If NOT globalTradingEnabled AND MarketPosition &lt;&gt; 0 Then Begin
    Print(&quot;*** FERMETURE FORCEE - LIMITE ATTEINTE ***&quot;);
    If NOT dailyTradingEnabled Then Print(&quot;Cause: Limite journali?re&quot;);
    If NOT weeklyTradingEnabled Then Print(&quot;Cause: Limite hebdomadaire&quot;);
    If NOT monthlyTradingEnabled Then Print(&quot;Cause: Limite mensuelle&quot;);
    
    If MarketPosition &gt; 0 Then
        Sell(&quot;Limit_Exit&quot;) currentcontracts contracts next bar at market
    Else
        BuyToCover(&quot;Limit_Exit&quot;) next bar at market;
End;
{===========================================================}
{              TRAITEMENT PRINCIPAL DU SYSTEME              }
{===========================================================}

{===========================================================}
{           MODULE 1: CALCUL DES CONDITIONS GLOBALES        }
{===========================================================}

{Calcul des conditions de session une seule fois}
currentTime = Time;
currentDate = Date;
isFriday = DayOfWeek(currentDate) = 5;
inTradingHours = (currentTime &gt;= session_StartTime AND currentTime &lt;= session_EndTime);
inPauseTime = (currentTime &gt;= session_PauseStart1 AND currentTime &lt;= session_PauseEnd1);
canTradeLong = param_playLong AND inTradingHours AND NOT inPauseTime;
canTradeShort = param_playShort AND inTradingHours AND NOT inPauseTime;

{Recuperer le prix actuel une seule fois}
currentPrice = Close;

{===========================================================}
{           MODULE 2: CALCUL DES INDICATEURS PAR UT         }
{===========================================================}

{BOUCLE PRINCIPALE OPTIMIS?E}
For timeframeIdx = TF_15MIN To TF_MONTHLY 
Begin
    {Variables locales factoris?es pour les calculs}
    Vars: 
        m7(0), m7_1(0), m7_2(0), m7_3(0),
        m20(0), m20_1(0), m20_2(0), m20_3(0),
        close_1(0), close_2(0), close_3(0),
        currentPhase(&quot;&quot;),
        supportCounter(0), resistanceCounter(0),
        minSupportValue(999999), minResistanceValue(999999);
    
    {Selection du bon flux de donnees selon le timeframe}
    If timeframeIdx = TF_15MIN Then dataStream = 1
    Else If timeframeIdx = TF_1HOUR Then dataStream = 2
    Else If timeframeIdx = TF_4HOUR Then dataStream = 3
    Else If timeframeIdx = TF_DAILY Then dataStream = 4
    Else If timeframeIdx = TF_WEEKLY Then dataStream = 5
    Else dataStream = 6;
    
    {CALCUL DES INDICATEURS PRINCIPAUX - FACTORIS?}
    UTData[timeframeIdx, IDX_M7] = Average(Close of data(dataStream), 7);
    UTData[timeframeIdx, IDX_M20] = Average(Close of data(dataStream), 20);
    UTData[timeframeIdx, IDX_SAR] = ATS_ParabolicSAR_TF(0.02, 0.02, 0.2) of Data(dataStream);
    
    {Calcul des Bandes de Bollinger factoris?}
    bbMiddle = UTData[timeframeIdx, IDX_M20];
    bbStdDev = StandardDev(Close of data(dataStream), 20, 1);
    UTData[timeframeIdx, IDX_BBH] = bbMiddle + 2 * bbStdDev;
    UTData[timeframeIdx, IDX_BBL] = bbMiddle - 2 * bbStdDev;
    
    {Calcul des Oggy et Jack}
    UTData[timeframeIdx, IDX_OGGY1] = Close[7] of data(dataStream);
    UTData[timeframeIdx, IDX_OGGY2] = Close[6] of data(dataStream);
    UTData[timeframeIdx, IDX_OGGY3] = Close[5] of data(dataStream);
    UTData[timeframeIdx, IDX_JACK1] = Close[20] of data(dataStream);
    UTData[timeframeIdx, IDX_JACK2] = Close[19] of data(dataStream);
    UTData[timeframeIdx, IDX_JACK3] = Close[18] of data(dataStream);
    
    {===========================================================}
    {     MODULE 2.1: DETERMINATION DES PHASES DE BOLLINGER     }
    {===========================================================}
    
    m7 = UTData[timeframeIdx, IDX_M7];
    m7_1 = Average(Close[1] of data(dataStream), 7);
    m7_2 = Average(Close[2] of data(dataStream), 7);
    
    {Calcul des phases de Bollinger simplifi?}
    bbUpper = UTData[timeframeIdx, IDX_BBH];
    bbLower = UTData[timeframeIdx, IDX_BBL];
    
    {Calcul des valeurs pr?c?dentes pour comparaison}
    bbStdDev = StandardDev(Close[1] of data(dataStream), 20, 1);
    bbMiddle = Average(Close[1] of data(dataStream), 20);
    Vars: bbUpper_1(0), bbLower_1(0);
    bbUpper_1 = bbMiddle + 2 * bbStdDev;
    bbLower_1 = bbMiddle - 2 * bbStdDev;
    
    {Logique de phases simplifi?e}
    If (bbUpper &gt; bbUpper_1 AND bbLower &lt; bbLower_1) Then 
    Begin {Expansion}
        If m7 &gt; m7_1 Then
            currentPhase = &quot;P2H&quot;
        Else 
        	If m7 &lt; m7_1 Then
            		currentPhase = &quot;P2B&quot;
        	Else
            		currentPhase = &quot;P4&quot;;
    End
    Else 
    	If (bbUpper &lt; bbUpper_1 AND bbLower &gt; bbLower_1) Then {Contraction}
       	currentPhase = &quot;P4&quot;
    	Else 
    		If (bbUpper &gt;= bbUpper_1 AND bbLower &gt;= bbLower_1) Then {Mont?e}
        		currentPhase = &quot;P3H&quot;
    		Else 
    			If (bbUpper &lt;= bbUpper_1 AND bbLower &lt;= bbLower_1) Then {Descente}
        			currentPhase = &quot;P3B&quot;
    			Else
        			currentPhase = &quot;P1&quot;;
        			
    {CORRECTIONS DES SEQUENCES PRINCIPALES DE PHASES}    					
    if currentPhase = &quot;P1&quot; and UTBollPhase[timeframeIdx][1] = &quot;P2H&quot; Then currentPhase=&quot;P2H&quot;;
    if currentPhase = &quot;P1&quot; and UTBollPhase[timeframeIdx][1] = &quot;P2B&quot; Then currentPhase=&quot;P2B&quot;;
    if currentPhase = &quot;P1&quot; and UTBollPhase[timeframeIdx][1] = &quot;P4&quot; and (bbUpper &lt; bbUpper_1 AND bbLower &gt; bbLower_1) Then currentPhase=&quot;P4&quot;;
    if currentPhase = &quot;P4&quot; and UTBollPhase[timeframeIdx][1] = &quot;P1&quot; then currentPhase=&quot;P1&quot;;
    if currentPhase = &quot;P3B&quot; and UTBollPhase[timeframeIdx][1] = &quot;P1&quot; then currentPhase=&quot;P1&quot;;
    if currentPhase = &quot;P3H&quot; and UTBollPhase[timeframeIdx][1] = &quot;P1&quot; then currentPhase=&quot;P1&quot;;

    
    
    {Mettre a jour la phase de Bollinger pour ce timeframe}
    UTBollPhase[timeframeIdx] = currentPhase;
    
    
    { ============== CALCUL DE LA DUREE EN P2H ============== }
    If UTBollPhase[timeframeIdx] = &quot;P2H&quot; Then 
    Begin
      { Si on ?tait d?j? en P2H la barre pr?c?dente, incr?menter le compteur }
    	If UTBollPhase[timeframeIdx][1] = &quot;P2H&quot; Then
      	UTDureeP2H[timeframeIdx] = UTDureeP2H[timeframeIdx] + 1
      Else
      	UTDureeP2H[timeframeIdx] = 1;  // Premi?re barre en P2H
	End
    Else Begin
	    { Si on n&#39;est plus en P2H, remettre le compteur ? z?ro }
	    UTDureeP2H[timeframeIdx] = 0;
    End;
    
    
    {===========================================================}
    {     MODULE 2.2: DETECTION DES SIGNAUX DE TENDANCE         }
    {===========================================================}

    m7 = UTData[timeframeIdx, IDX_M7];
    m7_1 = Average(Close[1] of data(dataStream), 7);
    m7_2 = Average(Close[2] of data(dataStream), 7);
    m7_3 = Average(Close[3] of data(dataStream), 7);

    m20 = UTData[timeframeIdx, IDX_M20];
    m20_1 = Average(Close[1] of data(dataStream), 20);
    m20_2 = Average(Close[2] of data(dataStream), 20);
    m20_3 = Average(Close[3] of data(dataStream), 20);

    
    close_1 = Close[1] of data(dataStream);
    close_2 = Close[2] of data(dataStream);
    close_3 = Close[3] of data(dataStream);
    
    {Variables pour les calculs de signaux - FACTORIS?}
    Vars:
        m7_crossover_m20(false), m7_crossunder_m20(false),
        m7_haussiere(false), m20_haussiere(false),
        m7_baissiere(false), m20_baissiere(false),
        m20_haussiere_3_periodes (false), m7_au_dessus_m20_3_periodes (false), m7_devient_haussiere (false),
        m20_baissiere_3_periodes (false), m7_en_dessous_m20_3_periodes (false), m7_devient_baissiere(false),
        signalFound(false);
    
    m7_crossover_m20 = (m7_1 &lt; m20_1 AND m7 &gt; m20);
    m7_crossunder_m20 = (m7_1 &gt; m20_1 AND m7 &lt; m20);
    m7_haussiere = (m7 &gt; m7_1);
    m20_haussiere = (m20 &gt; m20_1);
    m7_baissiere = (m7 &lt; m7_1);
    m20_baissiere = (m20 &lt; m20_1);
    
    signalFound = false;
    
    {Detection des croisements - SIMPLIFI?}
    If m7_crossover_m20 Then Begin
        If m7_haussiere AND m20_haussiere Then
            UTLastSignalCode[timeframeIdx] = &quot;XH&quot;
        Else
            UTLastSignalCode[timeframeIdx] = &quot;xH&quot;;
        UTLastSignalDistance[timeframeIdx] = 0;
        signalFound = true;
    End
    Else If m7_crossunder_m20 Then Begin
        If m7_baissiere AND m20_baissiere Then
            UTLastSignalCode[timeframeIdx] = &quot;XB&quot;
        Else
            UTLastSignalCode[timeframeIdx] = &quot;xB&quot;;
        UTLastSignalDistance[timeframeIdx] = 0;
        signalFound = true;
    End;
    
    {Detection NXH/NXB - SIMPLIFI?}
	{CAS N?3 HAUSSIER : NON CROISEMENT HAUSSIER}
	m20_haussiere_3_periodes    =  m20_3&lt;m20_2 and m20_2&lt;m20_1 and m20_1 &lt; m20 ;
	m7_au_dessus_m20_3_periodes =  m7_2&gt;m20_2 and m7_1&gt;m20_1 and m7&gt;m20;
	m7_devient_haussiere		=  m7_1&lt;m7_2 and m7_2&lt;m7_3 and m7&gt;m7_1+1 ;
	
	If ( m20_haussiere_3_periodes and m7_au_dessus_m20_3_periodes and m7_devient_haussiere) Then Begin
		UTLastSignalCode[timeframeIdx] = &quot;NXH&quot;;
		UTLastSignalDistance[timeframeIdx] = 0;
		signalFound = true;
	End;
	
	{CAS 3 BAISSIER : NON CROISEMENT BAISSIER}
 	m20_baissiere_3_periodes     = m20_3&gt;m20_2 and m20_2&gt;m20_1 and m20_1 &gt; m20 ;
 	m7_en_dessous_m20_3_periodes = m7_2&lt;m20_2 and m7_1&lt;m20_1 and m7&lt;m20;
 	m7_devient_baissiere 	 =  m7_1&gt;m7_2 and m7_2&gt;m7_3 and m7&lt;m7_1 ;

	If ( m20_baissiere_3_periodes and m7_en_dessous_m20_3_periodes and m7_devient_baissiere) Then Begin
		UTLastSignalCode[timeframeIdx] = &quot;NXB&quot;;
		UTLastSignalDistance[timeframeIdx] = 0;
		signalFound = true;
	End;
	
	// D?tection XPH (croisement SAR/M20)
	Vars: sar_cross_m20_up(false), sar_cross_m20_down(false);

	sar_cross_m20_up = (UTData[timeframeIdx, IDX_SAR][1] &gt; UTData[timeframeIdx, IDX_M20][1] AND 
	                    UTData[timeframeIdx, IDX_SAR] &lt; UTData[timeframeIdx, IDX_M20]);
	sar_cross_m20_down = (UTData[timeframeIdx, IDX_SAR][1] &lt; UTData[timeframeIdx, IDX_M20][1] AND 
	                      UTData[timeframeIdx, IDX_SAR] &gt; UTData[timeframeIdx, IDX_M20]);

	If sar_cross_m20_up Then Begin
	    UTLastSignalCode[timeframeIdx] = &quot;XPH&quot;;
	    UTLastSignalDistance[timeframeIdx] = 0;
	    signalFound = true;
	End
	Else If sar_cross_m20_down Then Begin
	    UTLastSignalCode[timeframeIdx] = &quot;XPB&quot;;
	    UTLastSignalDistance[timeframeIdx] = 0;
	    signalFound = true;
	End;
    //End;
    
    {Si aucun nouveau signal, incrementer la distance}
    If NOT signalFound AND UTLastSignalDistance[timeframeIdx] &lt; 9999 Then
        UTLastSignalDistance[timeframeIdx] = UTLastSignalDistance[timeframeIdx] + 1;
    
    {===========================================================}
    {     MODULE 2.3: IDENTIFICATION DES SUPPORTS/RESISTANCES   }
    {===========================================================}
    
    {Remplir le tableau des indicateurs une seule fois}
    IndicatorsValueArray[timeframeIdx, 1, 1] = UTData[timeframeIdx, IDX_M7];
    IndicatorsNameArray[timeframeIdx, 1, 1] = &quot;M7-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 1, 2] = IFF(UTData[timeframeIdx, IDX_M7] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 2, 1] = UTData[timeframeIdx, IDX_M20];
    IndicatorsNameArray[timeframeIdx, 2, 1] = &quot;M20-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 2, 2] = IFF(UTData[timeframeIdx, IDX_M20] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 3, 1] = UTData[timeframeIdx, IDX_BBH];
    IndicatorsNameArray[timeframeIdx, 3, 1] = &quot;U-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 3, 2] = IFF(UTData[timeframeIdx, IDX_BBH] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 4, 1] = UTData[timeframeIdx, IDX_BBL];
    IndicatorsNameArray[timeframeIdx, 4, 1] = &quot;L-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 4, 2] = IFF(UTData[timeframeIdx, IDX_BBL] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 5, 1] = UTData[timeframeIdx, IDX_SAR];
    IndicatorsNameArray[timeframeIdx, 5, 1] = &quot;SAR-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 5, 2] = IFF(UTData[timeframeIdx, IDX_SAR] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 6, 1] = UTData[timeframeIdx, IDX_OGGY1];
    IndicatorsNameArray[timeframeIdx, 6, 1] = &quot;O1-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 6, 2] = IFF(UTData[timeframeIdx, IDX_OGGY1] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 7, 1] = UTData[timeframeIdx, IDX_OGGY2];
    IndicatorsNameArray[timeframeIdx, 7, 1] = &quot;O2-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 7, 2] = IFF(UTData[timeframeIdx, IDX_OGGY2] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 8, 1] = UTData[timeframeIdx, IDX_OGGY3];
    IndicatorsNameArray[timeframeIdx, 8, 1] = &quot;O3-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 8, 2] = IFF(UTData[timeframeIdx, IDX_OGGY3] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 9, 1] = UTData[timeframeIdx, IDX_JACK1];
    IndicatorsNameArray[timeframeIdx, 9, 1] = &quot;J1-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 9, 2] = IFF(UTData[timeframeIdx, IDX_JACK1] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 10, 1] = UTData[timeframeIdx, IDX_JACK2];
    IndicatorsNameArray[timeframeIdx, 10, 1] = &quot;J2-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 10, 2] = IFF(UTData[timeframeIdx, IDX_JACK2] &gt; currentPrice, 1, -1);
    
    IndicatorsValueArray[timeframeIdx, 11, 1] = UTData[timeframeIdx, IDX_JACK3];
    IndicatorsNameArray[timeframeIdx, 11, 1] = &quot;J3-&quot;+UTNames[timeframeIdx];
    IndicatorsValueArray[timeframeIdx, 11, 2] = IFF(UTData[timeframeIdx, IDX_JACK3] &gt; currentPrice, 1, -1);
    
    {Calcul du ClosestSupport et ClosestResistance avec v?rifications}
    Arrays: supports[15](0), resistances[15](0);
    supportCounter = 0;
    resistanceCounter = 0;

    For indicatorIdx = 1 to 11 Begin
        If indicatorIdx &lt;= 11 AND 
           IndicatorsValueArray[timeframeIdx, indicatorIdx, 2] &lt; 0 AND 
           IndicatorsValueArray[timeframeIdx, indicatorIdx, 1] &gt; 0 AND
           supportCounter &lt; 14 Then Begin
            supportCounter = supportCounter + 1;
            supports[supportCounter] = IndicatorsValueArray[timeframeIdx, indicatorIdx, 1];
        End
        Else If indicatorIdx &lt;= 11 AND
                IndicatorsValueArray[timeframeIdx, indicatorIdx, 2] &gt; 0 AND
                IndicatorsValueArray[timeframeIdx, indicatorIdx, 1] &gt; 0 AND
                resistanceCounter &lt; 14 Then Begin
            resistanceCounter = resistanceCounter + 1;
            resistances[resistanceCounter] = IndicatorsValueArray[timeframeIdx, indicatorIdx, 1];
        End;
    End;
    
    {Trouver les plus proches avec v?rifications de limites}
    If supportCounter &gt; 0 Then Begin
        minSupportValue = supports[1];
        For indicatorIdx = 2 to supportCounter Begin
            If indicatorIdx &lt;= supportCounter AND indicatorIdx &lt;= 14 Then Begin
                If supports[indicatorIdx] &gt; minSupportValue Then
                    minSupportValue = supports[indicatorIdx];
            End;
        End;
        UTData[timeframeIdx, IDX_CLOSEST_SUPPORT] = minSupportValue;
    End
    Else
        UTData[timeframeIdx, IDX_CLOSEST_SUPPORT] = 0;

    If resistanceCounter &gt; 0 Then Begin
        minResistanceValue = resistances[1];
        For indicatorIdx = 2 to resistanceCounter Begin
            If indicatorIdx &lt;= resistanceCounter AND indicatorIdx &lt;= 14 Then Begin
                If resistances[indicatorIdx] &lt; minResistanceValue Then
                    minResistanceValue = resistances[indicatorIdx];
            End;
        End;
        UTData[timeframeIdx, IDX_CLOSEST_RESISTANCE] = minResistanceValue;
    End
    Else
        UTData[timeframeIdx, IDX_CLOSEST_RESISTANCE] = 0;
End;

{===========================================================}
{           MODULE 3: GRANDE FENETRE ET AGREGATION          }
{===========================================================}

{Initialisation des variables et tableaux}
Vars: 
    supportIdx(0), resistanceIdx(0), allIndicatorsIdx(0), 
    utIdx(0), checkIdx(0), pdh(0), pdl(0), o1(0), c1(0), levelIdx (0);

{R?initialisation des tableaux}
For checkIdx = 1 to 100 Begin
    GF_Supports[checkIdx] = 0;
    GF_Resistances[checkIdx] = 0;
    GF_AllIndicatorsValue[checkIdx] = 0;
    GF_AllIndicatorsName[checkIdx] = &quot;&quot;;
End;

{Obtenir les donn?es du jour pr?c?dent}
OHLCPeriodsAgo(2,1, o1, pdh, pdl, c1);

{Remplissage des tableaux GF}
supportIdx = 0;
resistanceIdx = 0;
allIndicatorsIdx = 0;

For utIdx = TF_15MIN to TF_MONTHLY Begin
    For indicatorIdx = 1 to 11 Begin
        If IndicatorsValueArray[utIdx, indicatorIdx, 1] &gt; 0 AND allIndicatorsIdx &lt; 90 Then Begin
            allIndicatorsIdx = allIndicatorsIdx + 1;
            GF_AllIndicatorsValue[allIndicatorsIdx] = IndicatorsValueArray[utIdx, indicatorIdx, 1];
            GF_AllIndicatorsName[allIndicatorsIdx] = IndicatorsNameArray[utIdx, indicatorIdx, 1];
            
            If IndicatorsValueArray[utIdx, indicatorIdx, 2] &lt; 0 AND supportIdx &lt; 95  Then Begin
                supportIdx = supportIdx + 1;
                GF_Supports[supportIdx] = IndicatorsValueArray[utIdx, indicatorIdx, 1];
            End
            Else If IndicatorsValueArray[utIdx, indicatorIdx, 2] &gt; 0 AND resistanceIdx &lt; 95 Then Begin
                resistanceIdx = resistanceIdx + 1;
                GF_Resistances[resistanceIdx] = IndicatorsValueArray[utIdx, indicatorIdx, 1];
            End;
        End;
    End;
End;

{Ajout des niveaux suppl?mentaires avec classification automatique}
Arrays: levelValues[7](0), levelNames[7](&quot;&quot;), levelTypes[7](0);

{Initialiser les tableaux de niveaux}
levelValues[1] = pdh;    				levelNames[1] = &quot;PDH&quot;;
levelValues[2] = pdl;    	 		  	levelNames[2] = &quot;PDL&quot;; 
levelValues[3] = highW(1) ;   		 	levelNames[3] = &quot;PWH&quot;;
levelValues[4] = LowW(1)  ;				levelNames[4] = &quot;PWL&quot;;
levelValues[5] = HighM(1) ;	       		levelNames[5] = &quot;PMH&quot;;
levelValues[6] = LowM(1)  ;        		levelNames[6] = &quot;PML&quot;;
levelValues[7] = Highest(High of Data(6),50);    levelNames[7] = &quot;ATH&quot;;

{Boucle pour traiter tous les niveaux}
For levelIdx = 1 to 7 Begin
    If allIndicatorsIdx &lt; 95 AND levelValues[levelIdx] &gt; 0 Then Begin
        {Ajouter au tableau global}
        allIndicatorsIdx = allIndicatorsIdx + 1;
        GF_AllIndicatorsValue[allIndicatorsIdx] = levelValues[levelIdx];
        GF_AllIndicatorsName[allIndicatorsIdx] = levelNames[levelIdx];
        
        {Classification automatique}
        If levelValues[levelIdx] &gt; currentPrice Then Begin
            {R?sistance}
            If resistanceIdx &lt; 95 Then Begin
                resistanceIdx = resistanceIdx + 1;
                GF_Resistances[resistanceIdx] = levelValues[levelIdx];
            End;
        End
        Else If levelValues[levelIdx] &lt; currentPrice Then Begin
            {Support}
            If supportIdx &lt; 95 Then Begin
                supportIdx = supportIdx + 1;
                GF_Supports[supportIdx] = levelValues[levelIdx];
            End;
        End;
    End;
End;


{Tri des tableaux avec v?rification de limites}
If supportIdx &gt; 1 Then
    Array_sort(GF_Supports, 1, supportIdx, false);
If resistanceIdx &gt; 1 Then
    Array_sort(GF_Resistances, 1, resistanceIdx, true);

{Calcul des plus proches globaux}
If supportIdx &gt; 0 Then
    GF_ClosestSupport = GF_Supports[1]
Else
    GF_ClosestSupport = 0;
    
If resistanceIdx &gt; 0 Then
    GF_ClosestResistance = GF_Resistances[1]
Else
    GF_ClosestResistance = 0;

{Detection des clusters avec v?rifications de limites}
SupportClusterCount = 0;
ResistanceClusterCount = 0;

If supportIdx &gt; 1 AND GF_ClosestSupport &gt; 0 Then Begin
    For checkIdx = 1 to supportIdx Begin
        If checkIdx &lt;= supportIdx AND checkIdx &lt;= 100 Then Begin
            If absvalue(GF_ClosestSupport - GF_Supports[checkIdx]) &lt;= param_ClusterPips Then
                SupportClusterCount = SupportClusterCount + 1;
        End;
    End;
End;

If resistanceIdx &gt; 1 AND GF_ClosestResistance &gt; 0 Then Begin
    For checkIdx = 1 to resistanceIdx Begin
        If checkIdx &lt;= resistanceIdx AND checkIdx &lt;= 100 Then Begin
            If absvalue(GF_Resistances[checkIdx] - GF_ClosestResistance) &lt;= param_ClusterPips Then
                ResistanceClusterCount = ResistanceClusterCount + 1;
        End;
    End;
End;

GF_isSupportCluster = (SupportClusterCount &gt; 3);
GF_isResistanceCluster = (ResistanceClusterCount &gt; 3);



{===========================================================}
{          MODULE 4: DETECTION DES SCENARIOS TRADING        }
{===========================================================}

Vars: buy_condition (false), UT1_Haussiere (false), UT2_Haussiere (false), UT3_Haussiere (false), UT4_Haussiere (false), UT5_Haussiere (false), UT6_Haussiere (false),
	UT1_Baissiere (false), UT2_Baissiere (false), UT3_Baissiere (false), UT4_Baissiere (false), UT5_Baissiere (false), UT6_Baissiere (false),
	UT1_LowSignal (false), UT2_LowSignal (false), UT3_LowSignal (false), UT4_LowSignal (false), UT5_LowSignal (false), UT6_LowSignal (false),
	cond_1_UT_Haussiere(false), cond_UT12_nonBaissiere(false), cond_noLowSignal(false), cond_ut_sup_haussiere (false), cond_no_trading_range(false), cond_aucune_ut_baissiere(false), cond_noContreSignal(false), cond_entree_nominale(false), 
	buy_uc1 (false), buy_other_uc (false), 	short_uc1b (false), short_other_uc (false), supertrend (0), st(0);
	

{R?initialisation}
GF_CodeScenarioLong = &quot;&quot;;
GF_PossibleScenarioLong = &quot;&quot;;
GF_CodeScenarioShort = &quot;&quot;;
GF_PossibleScenarioShort = &quot;&quot;;

{Calcul des signaux r?cents}
GF_SignauxHaussiers = &quot;&quot;;
GF_SignauxBaissiers = &quot;&quot;;
GF_NbSignauxHaussiersRecents = 0;
GF_NbSignauxBaissiersRecents = 0;

// reinits a chaque barre
buy_condition=false;
UT1_Haussiere= UTBollPhase[1]=&quot;P2H&quot; or UTBollPhase[1]=&quot;P3H&quot;; 
UT2_Haussiere= UTBollPhase[2]=&quot;P2H&quot; or UTBollPhase[2]=&quot;P3H&quot;; 
UT3_Haussiere= UTBollPhase[3]=&quot;P2H&quot; or UTBollPhase[3]=&quot;P3H&quot;;
UT4_Haussiere= UTBollPhase[4]=&quot;P2H&quot; or UTBollPhase[4]=&quot;P3H&quot;;
UT5_Haussiere= UTBollPhase[5]=&quot;P2H&quot; or UTBollPhase[5]=&quot;P3H&quot;;
UT6_Haussiere= UTBollPhase[6]=&quot;P2H&quot; or UTBollPhase[6]=&quot;P3H&quot;;

UT1_Baissiere= UTBollPhase[1]=&quot;P2B&quot; or UTBollPhase[1]=&quot;P3B&quot;;
UT2_Baissiere= UTBollPhase[2]=&quot;P2B&quot; or UTBollPhase[2]=&quot;P3B&quot;; 
UT3_Baissiere= UTBollPhase[3]=&quot;P2B&quot; or UTBollPhase[3]=&quot;P3B&quot;; 
UT4_Baissiere= UTBollPhase[4]=&quot;P2B&quot; or UTBollPhase[4]=&quot;P3B&quot;; 
UT5_Baissiere= UTBollPhase[5]=&quot;P2B&quot; or UTBollPhase[5]=&quot;P3B&quot;; 
UT6_Baissiere= UTBollPhase[6]=&quot;P2B&quot; or UTBollPhase[6]=&quot;P3B&quot;;

UT1_LowSignal= (UTLastSignalCode[1]=&quot;XB&quot; or UTLastSignalCode[1]=&quot;xB&quot; or UTLastSignalCode[1]=&quot;NXB&quot; or UTLastSignalCode[1]=&quot;XPB&quot; ) and UTLastSignalDistance[1]&lt;=5;
UT2_LowSignal= (UTLastSignalCode[2]=&quot;XB&quot; or UTLastSignalCode[2]=&quot;xB&quot; or UTLastSignalCode[2]=&quot;NXB&quot; or UTLastSignalCode[2]=&quot;XPB&quot; ) and UTLastSignalDistance[2]&lt;=20;
UT3_LowSignal= (UTLastSignalCode[3]=&quot;XB&quot; or UTLastSignalCode[3]=&quot;xB&quot; or UTLastSignalCode[3]=&quot;NXB&quot; or UTLastSignalCode[3]=&quot;XPB&quot; ) and UTLastSignalDistance[3]&lt;=65;
UT4_LowSignal= (UTLastSignalCode[4]=&quot;XB&quot; or UTLastSignalCode[4]=&quot;xB&quot; or UTLastSignalCode[4]=&quot;NXB&quot; or UTLastSignalCode[4]=&quot;XPB&quot; ) and UTLastSignalDistance[4]&lt;=300;
UT5_LowSignal= (UTLastSignalCode[5]=&quot;XB&quot; or UTLastSignalCode[5]=&quot;xB&quot; or UTLastSignalCode[5]=&quot;NXB&quot; or UTLastSignalCode[5]=&quot;XPB&quot; ) and UTLastSignalDistance[5]&lt;=1200;
UT6_LowSignal= (UTLastSignalCode[6]=&quot;XB&quot; or UTLastSignalCode[6]=&quot;xB&quot; or UTLastSignalCode[6]=&quot;NXB&quot; or UTLastSignalCode[6]=&quot;XPB&quot; ) and UTLastSignalDistance[6]&lt;=4000;

cond_1_UT_Haussiere= UT3_Haussiere or UT4_Haussiere or UT5_Haussiere or UT6_Haussiere;
cond_UT12_nonBaissiere= NOT (UT1_Baissiere or UT2_Baissiere);
cond_noLowSignal= NOT (UT1_LowSignal or UT2_LowSignal or UT3_LowSignal or UT4_LowSignal or UT5_LowSignal or UT6_LowSignal);
cond_ut_sup_haussiere= UT2_Haussiere ;
cond_no_trading_range = not (UTBollPhase[1]=&quot;P1&quot; or UTBollPhase[1]=&quot;P4&quot;);
cond_aucune_ut_baissiere= not (UT1_Baissiere or UT2_Baissiere or UT3_Baissiere or UT4_Baissiere or UT5_Baissiere or UT6_Baissiere);
cond_noContreSignal= GF_CodeScenarioLong&lt;&gt;&quot;&quot; and GF_CodeScenarioShort=&quot;&quot;;
supertrend= 0 ; //SuperTrendOliverSeban(10, 3, st);


cond_entree_nominale= cond_1_UT_Haussiere 
			 and cond_UT12_nonBaissiere 
			 // and cond_noLowSignal 
			 and GF_isSupportCluster 
			 and cond_ut_sup_haussiere ;
			 // and cond_aucune_ut_baissiere;

{ Variables pour conditions P2H avec filtre dur?e }
Vars:
    UT1_P2H_ValidDuration(false),
    UT2_P2H_ValidDuration(false),
    UT3_P2H_ValidDuration(false),
    anyUT_P2H_ValidDuration(false);

{ V?rifier si les timeframes ont une dur?e P2H dans la plage acceptable }
UT1_P2H_ValidDuration = UTBollPhase[1] = &quot;P2H&quot; AND 
                        UTDureeP2H[1] &gt;= param_MinDureeP2H AND 
                        UTDureeP2H[1] &lt;= param_MaxDureeP2H;

UT2_P2H_ValidDuration = UTBollPhase[2] = &quot;P2H&quot; AND 
                        UTDureeP2H[2] &gt;= param_MinDureeP2H AND 
                        UTDureeP2H[2] &lt;= param_MaxDureeP2H;


// Detection UC2 sur UT1 ou UT2:
if UTLastSignalCode[1]=&quot;XH&quot; or UTLastSignalCode[1]=&quot;NXH&quot; or UTLastSignalCode[1]=&quot;XPH&quot; and UTLastSignalDistance[1]&lt;2 Then
	GF_CodeScenarioLong=&quot;UC2&quot;;
if UTLastSignalCode[2]=&quot;XH&quot; or UTLastSignalCode[2]=&quot;NXH&quot; or UTLastSignalCode[2]=&quot;XPH&quot; and UTLastSignalDistance[2]&lt;8 Then
	GF_CodeScenarioLong=&quot;UC2&quot;;

// Detection UC1 P2H sur UT1:
if UTData[1, IDX_BBH]&gt;UTData[1, IDX_BBH][1] and UTData[1, IDX_BBL]&lt;UTData[1, IDX_BBL][1] and UTData[1, IDX_M7]&gt;UTData[1, IDX_M7][1] and UT1_P2H_ValidDuration Then // and (UTBollPhase[1]=&quot;P1&quot; or UTBollPhase[1]=&quot;P4&quot;) Then
	GF_CodeScenarioLong=&quot;UC1&quot;;
// Detection UC1 P2H sur UT2:
if UTData[2, IDX_BBH]&gt;UTData[2, IDX_BBH][4] and UTData[2, IDX_BBL]&lt;UTData[2, IDX_BBL][4] and UTData[2, IDX_M7]&gt;UTData[2, IDX_M7][4] and UT2_P2H_ValidDuration Then //and (UTBollPhase[2]=&quot;P1&quot; or UTBollPhase[2]=&quot;P4&quot;)Then
	GF_CodeScenarioLong=&quot;UC1&quot;;




buy_uc1 = param_uc1=1 and GF_CodeScenarioLong=&quot;UC1&quot;
 			 and (  PatternNeutralFast(LONG_UC1_PtnNeut_Yes,ohlcvalues) ) //or PatternNeutralFast(LONG_UC1_PtnNeut_Yes2,ohlcvalues) ) ;
 			 and (PatternNeutralFast(LONG_UC1_PtnNeut_No,ohlcvalues)=False)
                  and PatternDirectionalFast(LONG_UC1_PtnDir_No,ohlcvalues)=false;
//                  and PatternDirectionalFast(LONG_UC1_PtnDir_Yes,ohlcvalues) ;
// and ( (Not UT2_LowSignal and UTLastSignalDistance[2]&lt;20) or  (Not UT3_LowSignal and UTLastSignalDistance[3]&lt;65) ) ;

	   
buy_other_uc=  param_uc2=1 and GF_CodeScenarioLong&lt;&gt;&quot;&quot; and GF_CodeScenarioLong&lt;&gt;&quot;UC1&quot; and cond_entree_nominale and cond_no_trading_range and supertrend&lt;close
      		and PatternNeutralFast(LONG_UC2_PtnNeut_Yes,ohlcvalues) and (PatternNeutralFast(LONG_UC2_PtnNeut_No,ohlcvalues)=False)
                 and PatternDirectionalFast(LONG_UC2_PtnDir_No,ohlcvalues)=false ;

Vars:
	current_objective (0), objective_1 (0), objective_2(0), current_SL(0);

objective_1=  maxlist(GF_ClosestResistance, close+param_TPLong);

If arraysize(GF_Resistances)&gt;1 Then
	objective_2= maxlist(GF_Resistances[2], close+param_TPLong*1.5)
Else
	objective_2=0;
	

//if Close-GF_ClosestSupport-param_ClusterPips &gt;0 Then
// Ajouter la condition suivante: eviter Avril et surtout Aout : (MonthFromDateTime(DateTime) &lt;&gt;8 or MonthFromDateTime(DateTime) &lt;&gt;4)  and 
buy_condition =  Month(Date)&lt;&gt;noTradingMonth and dayofweek(Date)&lt;&gt;noTradingDay and (buy_uc1 or buy_other_uc) and GF_isSupportCluster and  adx(7)&gt;20 and globalTradingEnabled;


	 		


{===========================================================}
{          MODULE 6: GESTION DES ENTREES ET SORTIES         }
{===========================================================}
Vars:
	TradingWindow (false), WeekClosure (false), DayClosure (false), exit_EndSession_condition(false), exit_uc1 (false), current_trade_scenario (&quot;&quot;);
	



WeekClosure= param_CloseOnFriday=1 and dayofweekfromdatetime(currentdate)=5 ;
DayClosure= (param_ExitOnSessionClose=1) ;



if param_exit_uc1 = 1 Then Begin
	exit_uc1 =  UTData[1, IDX_BBH][1]&gt;UTData[1, IDX_BBH][2] and UTData[1, IDX_BBL][1]&lt;UTData[1, IDX_BBL][2] and UTData[1, IDX_BBH]&lt;UTData[1, IDX_BBH][1];
End
else
    if param_exit_uc1 = 2 Then begin
        exit_uc1 = UTData[1, IDX_SAR] &lt; UTData[1, IDX_SAR][1] and UTData[1, IDX_SAR][1]&gt; close[1];
    end
    else 
        if param_exit_uc1 = 3 Then begin
            exit_uc1 = close &lt; UTData[1, IDX_M20] and close[1]&gt;UTData[1, IDX_M20][1];
        end
        else
            if param_exit_uc1=0 Then begin
                exit_uc1=false;
            end;
            


exit_EndSession_condition= WeekClosure or DayClosure ;

	
TradingWindow= tw(session_StartTime, session_EndTime) ;
 {
	or (Time&lt;session_PauseStart2 or Time&gt;session_PauseEnd2)
	or (Time&lt;session_PauseStart3 or Time&gt;session_PauseEnd3)
	);
}

if marketposition=0 and buy_condition and TradingWindow
  and (Time&lt;session_PauseStart1 or Time&gt;session_PauseEnd1) 
  and (Time&lt;session_PauseStart2 or Time&gt;session_PauseEnd2)  Then // and TradingWindow and dayofweek(date) &lt;&gt; 5 Then
	Begin
		buy (GF_CodeScenarioLong) 2 Contracts next bar at market;
		current_objective= objective_1;
		current_trade_scenario=GF_CodeScenarioLong;
	End;
 

//setstoploss_pt(1000);//-param_ClusterPips);
//setprofittarget_pt (200);


// Gestion des TP Partiels et SL:

// Si on est en position avec 2 contrats alors on met le TP1  Objectif 1 et on monte le SL a BE
if MarketPosition = 1 and currentcontracts=2 and globalTradingEnabled then
	Begin
	    Sell(&quot;TP1_50pct&quot;) 1 contracts next bar at current_objective limit;
	    setstoploss_pt(param_SLLong);
	End;

// On change l&#39;objectif du trade si on est en position apres une prise de profit partielle d&#39;un contrat. 
// On affecte alors le nouvel objectif calcule (objective_1)
if marketposition = 1 and currentContracts=1 and currentContracts[1]=2  and globalTradingEnabled then
	current_objective=objective_1;

// Si on est en position avec un seul contrat, c&#39;est qu&#39;on vise le TP2 
if MarketPosition = 1 and currentcontracts=1  and globalTradingEnabled then
	Begin
	   //current_objective=100;
	   settrailingstop_pt(param_TrailingSL);
	   //Sell(&quot;TP2_50pct&quot;) 1 contracts next bar at current_objective limit;
	   //setstoploss_pt(absvalue(close-entryprice));
	   
	End;

//set ppfloor and ppratio to protect profit
Inputs:
    ppfloor(6000),    // Seuil de profit minimum avant d&#39;activer la sortie
    ppratio(0.80);    // Ratio de profit ? conserver (ex: 60%)

if MaxPositionProfit &gt;= ppfloor  and globalTradingEnabled then
begin
    // Si le profit latent est retomb? sous 60% du profit maximum atteint, on sort
    if (OpenPositionProfit / MaxPositionProfit) &lt; ppratio then
    begin
        Sell next bar at market;
        BuyToCover next bar at market;
    end;
end;


// Exit conditions
if marketposition=1 and exit_EndSession_condition and globalTradingEnabled  Then
	Begin
	setexitonclose;
	exit_EndSession_condition=false;
	End;
  
if marketposition=1 and exit_uc1 and current_trade_scenario=&quot;UC1&quot;  and globalTradingEnabled Then Begin
	Sell (&quot;Exit condition&quot;) currentcontracts contracts next bar at market;
	current_trade_scenario=&quot;&quot;;
End;
// setprofittarget_pt (objective_1);


{===========================================================}
{          MODULE 5: DISPLAY CONFIGURATION COMPL?TE        }
{===========================================================}

Vars:
    text_id(0), text_id1(0), text_id2(0), text_id3(0), 
    line_to_display(&quot;&quot;), supports_to_display(&quot;&quot;), resistances_to_display(&quot;&quot;),
    GF_isSupportCluster_String(&quot;&quot;), GF_isResistanceCluster_String(&quot;&quot;),
    srName(&quot;&quot;), idx_findSRName(0);

{Affichage des signaux r?cents}
If UTLastSignalDistance[TF_15MIN] &gt;= 3 Then
    text_delete(text_id1);
    
If UTLastSignalCode[TF_15MIN] &lt;&gt; &quot;NC&quot; AND UTLastSignalDistance[TF_15MIN] &lt; 2 Then
    text_id1 = text_new(date, time, high, UTLastSignalCode[TF_15MIN]);

If LastBarOnChart and DisplayATSConfiguration=1 Then Begin
    {Pr?paration des cha?nes pour les supports}
    srName = &quot;&quot;;
    supports_to_display = &quot;&quot;;
    
    For timeframeIdx = 1 to supportIdx Begin
        If GF_Supports[timeframeIdx] &lt;&gt; 0 AND timeframeIdx &lt;= supportIdx Then Begin
            idx_findSRName = array_indexof(GF_AllIndicatorsValue, GF_Supports[timeframeIdx]);
            If idx_findSRName &gt; 0 AND idx_findSRName &lt;= allIndicatorsIdx Then Begin
                srName = GF_AllIndicatorsName[idx_findSRName];
                supports_to_display = supports_to_display + srName + &quot; : &quot; + NumToStr(GF_Supports[timeframeIdx],0) + NewLine;
            End;
        End;
    End;
    
    {Pr?paration des cha?nes pour les r?sistances}
    srName = &quot;&quot;;
    resistances_to_display = &quot;&quot;;
    
    For timeframeIdx = 1 to resistanceIdx Begin
        If GF_Resistances[timeframeIdx] &lt;&gt; 0 AND timeframeIdx &lt;= resistanceIdx Then Begin
            idx_findSRName = array_indexof(GF_AllIndicatorsValue, GF_Resistances[timeframeIdx]);
            If idx_findSRName &gt; 0 AND idx_findSRName &lt;= allIndicatorsIdx Then Begin
                srName = GF_AllIndicatorsName[idx_findSRName];
                resistances_to_display = resistances_to_display + srName + &quot; : &quot; + NumToStr(GF_Resistances[timeframeIdx],0) + NewLine;
            End;
        End;
    End;

    {Pr?paration des cha?nes de cluster}
    If GF_isSupportCluster Then
        GF_isSupportCluster_String = &quot;YES&quot;
    Else 
        GF_isSupportCluster_String = &quot;NO&quot;;

    If GF_isResistanceCluster Then
        GF_isResistanceCluster_String = &quot;YES&quot;
    Else 
        GF_isResistanceCluster_String = &quot;NO&quot;;
        
    {Suppression de l&#39;ancien tableau}
    If text_id &gt;= 0 Then
        text_delete(text_id);

    {Tableau de configuration complet - RESTAUR?}
    line_to_display = &quot;&quot;;
    
    line_to_display = line_to_display + &quot;|            |     GF          |      UT1      |      UT2      |      UT3      |      UT4      |      UT5      |      UT6      |&quot; + NewLine;
    line_to_display = line_to_display + &quot;| M7         |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_M7],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_M7],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_M7],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_M7],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_M7],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_M7],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| M20        |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_M20],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_M20],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_M20],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_M20],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_M20],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_M20],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| BBH        |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_BBH],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_BBH],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_BBH],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_BBH],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_BBH],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_BBH],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| BBL        |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_BBL],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_BBL],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_BBL],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_BBL],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_BBL],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_BBL],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| SAR        |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_SAR],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_SAR],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_SAR],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_SAR],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_SAR],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_SAR],0) + &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| OGY1       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_OGGY1],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_OGGY1],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_OGGY1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_OGGY1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_OGGY1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_OGGY1],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| OGY2       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_OGGY2],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_OGGY2],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_OGGY2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_OGGY2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_OGGY2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_OGGY2],0) + &quot;   |     &quot; + NewLine;
    line_to_display = line_to_display + &quot;| OGY3       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_OGGY3],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_OGGY3],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_OGGY3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_OGGY3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_OGGY3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_OGGY3],0) + &quot;   |     &quot; + NewLine;
      
    line_to_display = line_to_display + &quot;| JAK1       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_JACK1],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_JACK1],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_JACK1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_JACK1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_JACK1],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_JACK1],0) + &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| JAK2       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_JACK2],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_JACK2],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_JACK2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_JACK2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_JACK2],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_JACK2],0) + &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| JAK3       |     N/A         |     &quot; + NumToStr(UTData[TF_15MIN, IDX_JACK3],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_JACK3],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_JACK3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_JACK3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_JACK3],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_JACK3],0) + &quot;   |     &quot; + NewLine;
      
    line_to_display = line_to_display + &quot;| Phase      |     N/A         |     &quot; + UTBollPhase[TF_15MIN] + &quot;      |     &quot; + UTBollPhase[TF_1HOUR] + &quot;     |     &quot;
      + UTBollPhase[TF_4HOUR] + &quot;     |     &quot; + UTBollPhase[TF_DAILY] + &quot;     |     &quot; + UTBollPhase[TF_WEEKLY] + &quot;     |     &quot; + UTBollPhase[TF_MONTHLY] + &quot;     |     &quot; + NewLine;
      
    line_to_display = line_to_display + &quot;| Sup.       |    &quot; + NumToStr(GF_ClosestSupport,0) + &quot;     |     &quot; + NumToStr(UTData[TF_15MIN, IDX_CLOSEST_SUPPORT],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_CLOSEST_SUPPORT],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_CLOSEST_SUPPORT],0)+ &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Clust      |    &quot; + GF_isSupportCluster_String + &quot;     |     N/A    |     N/A   |     &quot;
      + &quot;N/A   |     N/A   |     N/A   |     N/A   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Res.       |    &quot; + NumToStr(GF_ClosestResistance,0) + &quot;     |     &quot; + NumToStr(UTData[TF_15MIN, IDX_CLOSEST_RESISTANCE],0) + &quot;    |     &quot; + NumToStr(UTData[TF_1HOUR, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot;
      + NumToStr(UTData[TF_4HOUR, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot; + NumToStr(UTData[TF_DAILY, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot; + NumToStr(UTData[TF_WEEKLY, IDX_CLOSEST_RESISTANCE],0) + &quot;   |     &quot; + NumToStr(UTData[TF_MONTHLY, IDX_CLOSEST_RESISTANCE],0)+ &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Clust      |    &quot; + GF_isResistanceCluster_String + &quot;     |     N/A    |     N/A   |     &quot;
      + &quot;N/A   |     N/A   |     N/A   |     N/A   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Sign       |    N/A      |     &quot; + UTLastSignalCode[TF_15MIN] + &quot;    |     &quot; + UTLastSignalCode[TF_1HOUR] + &quot;   |     &quot;
      + UTLastSignalCode[TF_4HOUR] + &quot;   |     &quot; + UTLastSignalCode[TF_DAILY] + &quot;   |     &quot; + UTLastSignalCode[TF_WEEKLY] + &quot;   |     &quot; + UTLastSignalCode[TF_MONTHLY]+ &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + &quot;| Dist       |    N/A      |     &quot; + NumToStr(UTLastSignalDistance[TF_15MIN],0) + &quot;    |     &quot; + NumToStr(UTLastSignalDistance[TF_1HOUR],0) + &quot;   |     &quot;
      + NumToStr(UTLastSignalDistance[TF_4HOUR],0) + &quot;   |     &quot; + NumToStr(UTLastSignalDistance[TF_DAILY],0) + &quot;   |     &quot; + NumToStr(UTLastSignalDistance[TF_WEEKLY],0) + &quot;   |     &quot; + NumToStr(UTLastSignalDistance[TF_MONTHLY],0)+ &quot;   |     &quot; + NewLine;

    line_to_display = line_to_display + NewLine + &quot;SCENARIOS:&quot; + NewLine;
    line_to_display = line_to_display + &quot;Long: &quot; + GF_CodeScenarioLong + &quot; - &quot; + GF_PossibleScenarioLong + NewLine;
    line_to_display = line_to_display + &quot;Short: &quot; + GF_CodeScenarioShort + &quot; - &quot; + GF_PossibleScenarioShort + NewLine;

    text_id = text_new(date+1, time, high, line_to_display);

    {Affichage tableau des Supports et r?sistances - RESTAUR?}
    If text_id2 &gt; 0 Then
        text_delete(text_id2);

    If text_id3 &gt; 0 Then
        text_delete(text_id3);
        
    text_id2 = text_new(date, time, low, &quot;Resistances :&quot; + NewLine + resistances_to_display);
    text_id3 = text_new(date, time, currentPrice, &quot;Supports :&quot; + NewLine + supports_to_display);
End;

{ ============== TABLEAU DE BORD MULTI-HORIZONS ============== }
If LastBarOnChart AND DisplayPerfo = 1 Then Begin
    Vars: 
        multiHorizonDisplay(&quot;&quot;), 
        globalStatusColor(White),
        dailyStatusText(&quot;&quot;), weeklyStatusText(&quot;&quot;), monthlyStatusText(&quot;&quot;);
    
    { Pr?paration des textes de status }
    If dailyTradingEnabled Then 
        dailyStatusText = &quot;ACTIF&quot;
    Else 
        dailyStatusText = &quot;BLOQUE&quot;;
        
    If weeklyTradingEnabled Then 
        weeklyStatusText = &quot;ACTIF&quot;
    Else 
        weeklyStatusText = &quot;BLOQUE&quot;;
        
    If monthlyTradingEnabled Then 
        monthlyStatusText = &quot;ACTIF&quot;
    Else 
        monthlyStatusText = &quot;BLOQUE&quot;;
    
    { Construction du tableau }
    multiHorizonDisplay = &quot;=== PROFIT MULTI-HORIZONS ===&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Date: &quot; + NumToStr(Date, 0) + &quot; | Heure: &quot; + NumToStr(Time, 0) + NewLine ;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Total Net Profit: &quot; + NumToStr(NetProfit, 0)  + NewLine + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Contract Expiration Date: &quot; + datetostring(ExpirationDateFromVendor)  + NewLine + NewLine;

    
    { SECTION JOURNALIERE }
    multiHorizonDisplay = multiHorizonDisplay + &quot;--- JOURNALIER ---&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Profit: &quot; + NumToStr(dailyProfit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Limite: &quot; + NumToStr(param_DailyLossLimit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Trades: &quot; + NumToStr(dailyTradeCount, 0) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Status: &quot; + dailyStatusText + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Distance: &quot; + NumToStr(dailyProfit - param_DailyLossLimit, 2) + NewLine + NewLine;
    
    { SECTION HEBDOMADAIRE }
    multiHorizonDisplay = multiHorizonDisplay + &quot;--- HEBDOMADAIRE ---&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Profit: &quot; + NumToStr(weeklyProfit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Limite: &quot; + NumToStr(param_WeeklyLossLimit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Trades: &quot; + NumToStr(weeklyTradeCount, 0) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Status: &quot; + weeklyStatusText + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Distance: &quot; + NumToStr(weeklyProfit - param_WeeklyLossLimit, 2) + NewLine + NewLine;
    
    { SECTION MENSUELLE }
    multiHorizonDisplay = multiHorizonDisplay + &quot;--- MENSUEL ---&quot; + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Profit: &quot; + NumToStr(monthlyProfit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Limite: &quot; + NumToStr(param_MonthlyLossLimit, 2) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Trades: &quot; + NumToStr(monthlyTradeCount, 0) + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Status: &quot; + monthlyStatusText + NewLine;
    multiHorizonDisplay = multiHorizonDisplay + &quot;Distance: &quot; + NumToStr(monthlyProfit - param_MonthlyLossLimit, 2) + NewLine + NewLine;
    
    { STATUS GLOBAL }
    multiHorizonDisplay = multiHorizonDisplay + &quot;=== STATUS GLOBAL ===&quot; + NewLine;
    If globalTradingEnabled Then Begin
        multiHorizonDisplay = multiHorizonDisplay + &quot;TRADING: AUTORISE&quot; + NewLine;
        globalStatusColor = Green;
    End
    Else Begin
        multiHorizonDisplay = multiHorizonDisplay + &quot;TRADING: SUSPENDU&quot; + NewLine;
        globalStatusColor = Red;
    End;
    
    { Affichage }
    Vars: multiHorizonTextId(0);
    If multiHorizonTextId &gt; 0 Then
        text_delete(multiHorizonTextId);
        
    multiHorizonTextId = text_new(date, time + 200, high + 100, multiHorizonDisplay);
    text_setcolor(multiHorizonTextId, globalStatusColor);
End;

{ 9. FONCTION DE DEBUG DETAILLEE }

{ ============== DEBUG MULTI-HORIZONS ============== }
If Mod(BarNumber, 200) = 0 Then Begin  // Debug toutes les 200 barres
    Print(&quot;=== DEBUG MULTI-HORIZONS ===&quot;);
    Print(&quot;Barre: &quot;, BarNumber, &quot; | Date: &quot;, Date, &quot; | Time: &quot;, Time);
    Print(&quot;NetProfit total: &quot;, NetProfit);
    Print(&quot;Starts - Jour: &quot;, dailyStartProfit, &quot; | Semaine: &quot;, weeklyStartProfit, &quot; | Mois: &quot;, monthlyStartProfit);
    Print(&quot;Profits - Jour: &quot;, dailyProfit, &quot; | Semaine: &quot;, weeklyProfit, &quot; | Mois: &quot;, monthlyProfit);
    Print(&quot;Status - Jour: &quot;, dailyTradingEnabled, &quot; | Semaine: &quot;, weeklyTradingEnabled, &quot; | Mois: &quot;, monthlyTradingEnabled);
    Print(&quot;GLOBAL: &quot;, globalTradingEnabled);
End;

{ 10. STATISTIQUES AVANCEES PAR HORIZON }

{ Variables pour statistiques d?taill?es }
Vars:
    { === STATISTIQUES JOURNALIERES === }
    dailyWinTrades(0), dailyLossTrades(0),
    dailyGrossProfit(0), dailyGrossLoss(0),
    dailyLargestWin(0), dailyLargestLoss(0),
    
    { === STATISTIQUES HEBDOMADAIRES === }
    weeklyWinTrades(0), weeklyLossTrades(0),
    weeklyGrossProfit(0), weeklyGrossLoss(0),
    weeklyLargestWin(0), weeklyLargestLoss(0),
    
    { === STATISTIQUES MENSUELLES === }
    monthlyWinTrades(0), monthlyLossTrades(0),
    monthlyGrossProfit(0), monthlyGrossLoss(0),
    monthlyLargestWin(0), monthlyLargestLoss(0);

{ Mise ? jour des statistiques lors des sorties }
If MarketPosition = 0 AND MarketPosition[1] &lt;&gt; 0 Then Begin
    lastTradeExitProfit = NetProfit - NetProfit[1];
    
    { === STATS JOURNALIERES === }
    If Date = lastDailyResetDate Then Begin
        If lastTradeExitProfit &gt; 0 Then Begin
            dailyWinTrades = dailyWinTrades + 1;
            dailyGrossProfit = dailyGrossProfit + lastTradeExitProfit;
            If lastTradeExitProfit &gt; dailyLargestWin Then
                dailyLargestWin = lastTradeExitProfit;
        End
        Else If lastTradeExitProfit &lt; 0 Then Begin
            dailyLossTrades = dailyLossTrades + 1;
            dailyGrossLoss = dailyGrossLoss + lastTradeExitProfit;
            If lastTradeExitProfit &lt; dailyLargestLoss Then
                dailyLargestLoss = lastTradeExitProfit;
        End;
    End;
    
    { === STATS HEBDOMADAIRES === }
    If Date &gt;= lastWeeklyResetDate Then Begin
        If lastTradeExitProfit &gt; 0 Then Begin
            weeklyWinTrades = weeklyWinTrades + 1;
            weeklyGrossProfit = weeklyGrossProfit + lastTradeExitProfit;
            If lastTradeExitProfit &gt; weeklyLargestWin Then
                weeklyLargestWin = lastTradeExitProfit;
        End
        Else If lastTradeExitProfit &lt; 0 Then Begin
            weeklyLossTrades = weeklyLossTrades + 1;
            weeklyGrossLoss = weeklyGrossLoss + lastTradeExitProfit;
            If lastTradeExitProfit &lt; weeklyLargestLoss Then
                weeklyLargestLoss = lastTradeExitProfit;
        End;
    End;
    
    { === STATS MENSUELLES === }
    If Date &gt;= lastMonthlyResetDate Then Begin
        If lastTradeExitProfit &gt; 0 Then Begin
            monthlyWinTrades = monthlyWinTrades + 1;
            monthlyGrossProfit = monthlyGrossProfit + lastTradeExitProfit;
            If lastTradeExitProfit &gt; monthlyLargestWin Then
                monthlyLargestWin = lastTradeExitProfit;
        End
        Else If lastTradeExitProfit &lt; 0 Then Begin
            monthlyLossTrades = monthlyLossTrades + 1;
            monthlyGrossLoss = monthlyGrossLoss + lastTradeExitProfit;
            If lastTradeExitProfit &lt; monthlyLargestLoss Then
                monthlyLargestLoss = lastTradeExitProfit;
        End;
    End;
End;

{ 11. RESET DES STATISTIQUES LORS DES NOUVEAUX CYCLES }

{ Reset des stats journali?res }
If Date &lt;&gt; lastDailyResetDate OR (Time = param_DailyResetHour AND Time[1] &lt;&gt; param_DailyResetHour) Then Begin
    dailyWinTrades = 0; dailyLossTrades = 0;
    dailyGrossProfit = 0; dailyGrossLoss = 0;
    dailyLargestWin = 0; dailyLargestLoss = 0;
End;

{ Reset des stats hebdomadaires }
If DayOfWeek(Date) = param_WeeklyResetDay AND DayOfWeek(Date[1]) &lt;&gt; param_WeeklyResetDay Then Begin
    weeklyWinTrades = 0; weeklyLossTrades = 0;
    weeklyGrossProfit = 0; weeklyGrossLoss = 0;
    weeklyLargestWin = 0; weeklyLargestLoss = 0;
End;

{ Reset des stats mensuelles }
If DayOfMonth(Date) = param_MonthlyResetDay AND DayOfMonth(Date[1]) &lt;&gt; param_MonthlyResetDay Then Begin
    monthlyWinTrades = 0; monthlyLossTrades = 0;
    monthlyGrossProfit = 0; monthlyGrossLoss = 0;
    monthlyLargestWin = 0; monthlyLargestLoss = 0;
End;


//TITAN FAST EXPORT
input: TitanExportMode(0);
var: bin(0);
If TitanExportMode=1 then bin = writedailiesCTitanReports(1100101, TitanExportMode);

</pre></div>
        
        <p style="margin-top: 20px; color: #7f8c8d; font-size: 0.9em;">
            G√©n√©r√© le 2025-11-28 18:02 | 
            Hash: e9f0afbe0089...
        </p>
    </div>
</body>
</html>